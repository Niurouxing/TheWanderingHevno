### index.js
```
// src/index.js (附有详细注释文档)

/**
 * @file index.js
 * @description 插件的主入口文件。
 * @version 1.1.0
 *
 * @summary
 * 该文件负责插件的初始化，包括：
 * 1.  向SillyTavern页面注入插件的设置UI。
 * 2.  注册核心的生成拦截器 `HevnoInterceptor`，这是插件所有功能的核心。
 *
 * 【新开发者必读】
 * 插件的生命周期从 `jQuery(async () => { ... });` 开始，这确保了代码在页面DOM加载完毕后执行。
 * 核心逻辑位于 `globalThis.HevnoInterceptor` 函数中，请务必理解其工作流程。
 */

import { APP, USER, SYSTEM } from './core/manager.js';
import { loadSettings } from './scripts/settings/userExtensionSetting.js';
import { GenerationOrchestrator } from './core/orchestrator.js';
import { defaultPipeline } from './data/defaultPipeline.js';

console.log("______________________ Hevno Plugin: Loading ______________________");

/**
 * @function HevnoInterceptor
 * @global
 * @description (!!!) 插件的核心 - 生成拦截器。
 *
 * 【关键概念：生成拦截器 (Generation Interceptor)】
 * 这是通过 `manifest.json`中的 `generate_interceptor` 字段注册到SillyTavern的全局函数。
 * 在SillyTavern每次准备向LLM发送请求之前，它会“暂停”并调用这个函数，给予插件干预的机会。
 *
 * 【核心工作流：拦截 -> 执行 -> 喂回】
 * 这个函数的设计遵循了一个健壮的模式，以确保与SillyTavern的深度和安全集成：
 * 1.  **拦截 (Intercept)**: 通过调用 `abort(true)`，我们立即中止SillyTavern的默认生成流程，完全接管控制权。
 * 2.  **执行 (Execute)**: 这是我们插件自定义逻辑的执行阶段。在这里，我们可以进行自己的LLM调用、
 *     数据处理，或者像这个例子一样，简单地准备一个固定的字符串。
 * 3.  **喂回 (Feed-back)**: 我们不直接操作DOM，而是将我们的最终结果通过 `APP.saveReply()` 函数
 *     “喂回”给SillyTavern。SillyTavern会像处理一个真实的AI回复一样，负责后续所有的UI渲染、
 *     事件触发和状态更新。这是最推荐的集成方式。
 * 4.  **清理 (Cleanup)**: 在 `finally` 块中，必须调用 `APP.unblockGeneration()` 来解锁UI，
 *     无论流程成功与否，这都能防止界面卡死。
 *
 * @param {Array} chat - 即将用于构建prompt的聊天历史数组（在此模式下我们通常不直接修改它）。
 * @param {Number} contextSize - 当前的token计数。
 * @param {Function} abort - 中止函数。调用 `abort(true)` 来中止并阻止其他拦截器运行。
 * @param {String} type - 触发生成的类型 (e.g., 'send', 'regenerate', 'swipe')。
 */
globalThis.HevnoInterceptor = async function (chat, contextSize, abort, type) {
    const settings = USER.settings;

    if (!settings.isEnabled) {
        return;
    }

    console.log(`[Hevno] Intercepting generation of type: ${type}`);
    abort(true);

    try {
        console.log("[Hevno] Starting modular generation pipeline...");

        // 【修改】从用户设置中动态获取管线定义
        // USER.settings.pipeline 会自动从SillyTavern的存储中读取，
        // 如果没有，则回退到我们在 pluginSetting.js 中定义的默认值。
        const pipelineDefinition = USER.settings.pipeline;

        if (!pipelineDefinition || !Array.isArray(pipelineDefinition) || pipelineDefinition.length === 0) {
            toastr.error("Hevno pipeline is missing or invalid. Please import a valid pipeline in settings.", "Pipeline Error");
            console.error("[Hevno] No valid pipeline found in settings.");
            return;
        }

        const orchestrator = new GenerationOrchestrator(pipelineDefinition, APP.getContext());

        const finalOutput = await orchestrator.run();

        if (!finalOutput) {
            console.warn("[Hevno] Pipeline ran, but produced no final output.");
            // 即使没有输出，也需要一个空回复来完成流程
            await APP.saveReply({ type: 'normal', getMessage: '' });
        } else {
            await APP.saveReply({
                type: 'normal',
                getMessage: finalOutput,
                title: 'Generated by Hevno Modular Pipeline',
            });
        }

        await APP.saveChatConditional();

        console.log(`[Hevno] Generation completed via modular pipeline.`);

    } catch (error) {
        console.error("[Hevno] An error occurred during the modular pipeline execution:", error);
        toastr.error(`The Hevno Plugin encountered an error: ${error.message}`, "Pipeline Error");
    } finally {
        APP.unblockGeneration(type);
    }
};
/**
 * 插件的主初始化函数。
 * 使用 jQuery(async () => { ... }) 确保在文档对象模型(DOM)完全加载和解析完毕后执行。
 * 这是Web开发的标准实践，可以防止因尝试操作不存在的元素而导致的错误。
 */
jQuery(async () => {
    try {
        const script = document.createElement('script');
        script.type = 'module';
        script.innerHTML = `
            import { GoogleGenerativeAI } from 'https://esm.run/@google/generative-ai';
            window.GoogleGenerativeAI = GoogleGenerativeAI;
        `;
        document.head.appendChild(script);
        console.log('[Hevno] Google Generative AI SDK script injected.');
    } catch (error) {
        console.error('[Hevno] Failed to inject Google AI SDK.', error);
        toastr.error("Failed to load Google AI library. Gemini features will not work.", "Dependency Error");
    }

    // 任务1: 注入插件的设置UI界面。
    try {
        // 使用我们封装的 SYSTEM 管理器来异步加载HTML模板。
        const settingsHtml = await SYSTEM.getTemplate('settings');

        // 使用jQuery将加载的HTML内容附加到SillyTavern的扩展设置面板中。
        // '#extensions_settings' 是SillyTavern中用于放置所有插件设置的容器ID。
        $('#extensions_settings').append(settingsHtml);

        // 加载设置的初始值并为UI元素绑定事件监听器。
        loadSettings();

    } catch (error) {
        console.error("[Hevno] Failed to load settings UI.", error);
    }

    console.log("______________________ Hevno Plugin: Loaded Successfully ______________________");
});
```

### llm_callers/gemini_caller.js
```
// src/llm_callers/gemini_caller.js

import { apiKeyManager } from '../core/apiKeyManager.js';

/**
 * 执行对Google Gemini API的调用。
 * @param {string} prompt - 完整的、渲染后的prompt。
 * @param {object} llmConfig - 来自模块定义的LLM配置。
 * @returns {Promise<string>} LLM生成的文本。
 */
export async function execute(prompt, llmConfig) {
    const { model, temperature = 0.7, topP = 1.0, maxOutputTokens = 2048 } = llmConfig;

    // 检查 window.GoogleGenerativeAI 是否已加载
    if (typeof window.GoogleGenerativeAI === 'undefined') {
        throw new Error("Google Generative AI SDK is not loaded.");
    }
    
    const key = apiKeyManager.acquireKey();
    try {
        const genAI = new window.GoogleGenerativeAI(key);

        const generativeModel = genAI.getGenerativeModel({
            model: model,
            generationConfig: {
                temperature,
                topP,
                maxOutputTokens,
            },
        });
        
        // Gemini API 需要一个内容数组
        const contents = [{ role: "user", parts: [{ text: prompt }] }];
        
        console.log(`[GeminiCaller] Sending request to model: ${model}`);
        const result = await generativeModel.generateContent({ contents });
        const response = await result.response;
        
        return response.text();

    } catch (error) {
        console.error("[GeminiCaller] Error during API call:", error);
        // 重新抛出错误，以便Orchestrator可以捕获它
        throw new Error(`Gemini API Error: ${error.message}`);
    } finally {
        // 无论成功与否，都必须释放密钥
        apiKeyManager.releaseKey(key);
    }
}
```

### core/llm_dispatcher.js
```
// src/core/llm_dispatcher.js

import * as geminiCaller from '../llm_callers/gemini_caller.js';
// 未来可以在这里添加更多caller:
// import * as openaiCaller from '../llm_callers/openai_caller.js';

const providers = {
    'gemini': geminiCaller,
    // 'openai': openaiCaller,
};

/**
 * 根据llmConfig中的provider，将请求分派给正确的LLM调用者。
 * @param {string} prompt - 渲染后的prompt。
 * @param {object} llmConfig - 模块的LLM配置。
 * @returns {Promise<string>} 来自LLM的响应。
 */
export async function dispatch(prompt, llmConfig) {
    const providerName = llmConfig.provider;
    if (!providerName) {
        throw new Error("Module is missing 'provider' field in its 'llm' configuration.");
    }

    const caller = providers[providerName.toLowerCase()];
    if (!caller) {
        throw new Error(`Unsupported LLM provider: "${providerName}". No caller found.`);
    }

    return await caller.execute(prompt, llmConfig);
}
```

### core/manager.js
```
// src/core/manager.js (附有详细注释文档)

/**
 * @file manager.js
 * @description 插件的核心管理器和API抽象层。
 * @version 1.1.0
 *
 * @see README.md - 插件的整体架构设计。
 *
 * @summary
 * 这个文件是插件与SillyTavern进行交互的唯一桥梁。它将SillyTavern复杂、有时甚至是全局的API
 * 封装成一组逻辑清晰、易于管理的单例对象（APP, USER, EDITOR, SYSTEM）。
 *
 * 【新开发者必读】
 * 任何与SillyTavern的直接交互（如调用函数、获取数据）都应该首先在这里进行封装。
 * 插件的其他部分（如index.js）应优先调用这里的管理器，而不是直接触碰SillyTavern的API。
 * 这种设计模式（称为“外观模式”或“适配器模式”）有以下好处：
 * 1.  **解耦**: 插件的业务逻辑与SillyTavern的实现细节分离。
 * 2.  **可维护性**: 如果SillyTavern未来更新了API，我们只需要修改这个文件，而不用改动整个插件。
 * 3.  **清晰性**: 提供了清晰的API边界，新开发者能快速了解插件可用的所有SillyTavern功能。
 */

// ===================================================================================
// I. 导入SillyTavern的核心功能
// ===================================================================================
// 注意: 导入路径是相对于SillyTavern的 /public/ 目录的。

// 从 /script.js 导入SillyTavern的核心功能函数。
// 这些函数大多是经过 `export` 关键字明确导出的“公共API”。
import {
    // 事件系统
    eventSource,
    event_types,
    // 设置与持久化
    saveSettingsDebounced,
    // 核心消息处理 (!!!)
    saveReply,
    saveChatConditional,
    activateSendButtons,
    // 其他常用工具
    addOneMessage,
    deleteLastMessage,
    generateRaw,
    reloadCurrentChat,
    sendSystemMessage,
    substituteParams,
    
} from '/script.js';

import {getTokenCountAsync} from '/scripts/tokenizers.js'; // 异步计算token数量的函数

// 从 /scripts/extensions.js 导入专门为插件提供的功能。
import { getContext, extension_settings, renderExtensionTemplateAsync } from '/scripts/extensions.js';
// 从 /scripts/popup.js 导入UI组件。
import { Popup, POPUP_TYPE, callGenericPopup } from '/scripts/popup.js';

// 导入插件自身的默认设置，作为回退方案。
import { defaultSettings } from '../data/pluginSetting.js';


// ===================================================================================
// II. 定义和导出管理器
// ===================================================================================

/**
 * @namespace APP
 * @description 应用管理器 (APP): 封装与SillyTavern应用本身交互的核心API。
 *              这是最常用的管理器，提供了对SillyTavern状态和核心流程的访问。
 */
export const APP = {
    // -----------------------------------------------------------------------------
    // 核心上下文与数据 API
    // -----------------------------------------------------------------------------

    /**
     * @function getContext
     * @description (!!!) 获取SillyTavern的全局上下文对象。这是访问所有运行时数据的入口。
     * @returns {object} 上下文对象，包含 chat, characters, settings, eventSource 等。
     * @see https://docs.sillytavern.app/extensions/api/context/
     */
    getContext,

    // -----------------------------------------------------------------------------
    // 事件系统 API
    // -----------------------------------------------------------------------------

    /**
     * @property {EventEmitter} eventSource
     * @description SillyTavern的事件发射器，用于监听应用内的各种事件。
     * @example APP.eventSource.on(APP.event_types.MESSAGE_RECEIVED, (messageId) => { ... });
     */
    eventSource,

    /**
     * @property {object} event_types
     * @description 一个包含所有可用事件名称的枚举对象。
     * @see https://docs.sillytavern.app/extensions/api/events/
     */
    event_types,

    // -----------------------------------------------------------------------------
    // 消息处理与生成流程控制 API
    // -----------------------------------------------------------------------------

    /**
     * @function saveReply
     * @description (!!!) 【推荐】将一个字符串作为AI回复注入SillyTavern的完整消息处理流程。
     *              这是实现“喂回”机制的核心，比 addOneMessage 更健壮。
     * @param {object} options - 包含回复信息的对象。
     * @example await APP.saveReply({ type: 'normal', getMessage: '你好！' });
     */
    saveReply,

    /**
     * @function activateSendButtons
     * @description (!!!) 【关键】解锁UI，重新启用发送按钮。在拦截并中止生成后，必须在finally块中调用此函数。
     *              这是 unblockGeneration 的安全、公共的替代品。
     */
    unblockGeneration: activateSendButtons,

    /**
     * @function generateRaw
     * @description 【未来可用】在后台静默发起一次LLM调用，不影响当前聊天界面。
     *              对于需要LLM进行数据处理的复杂插件（如摘要、翻译）非常有用。
     * @param {string} prompt - 要发送给LLM的提示。
     * @returns {Promise<string>} LLM生成的文本。
     */
    generateRaw,

    // -----------------------------------------------------------------------------
    // 聊天记录操作 API
    // -----------------------------------------------------------------------------

    /**
     * @function addOneMessage
     * @description 【未来可用】将一个标准格式的消息对象直接渲染到聊天界面。
     *              主要用于添加非AI生成的、系统性的消息。对于AI回复，应优先使用 saveReply。
     * @param {object} messageObject - 符合SillyTavern格式的消息对象。
     */
    addOneMessage,

    /**
     * @function sendSystemMessage
     * @description 【未来可用】一个更高级的函数，用于方便地发送格式化的系统消息。
     * @param {string} type - 系统消息类型, e.g., 'generic', 'comment'。
     * @param {string} text - 消息内容。
     */
    sendSystemMessage,

    /**
     * @function deleteLastMessage
     * @description 【未来可用】删除聊天记录中的最后一条消息。
     */
    deleteLastMessage,

    /**
     * @function reloadCurrentChat
     * @description 【未来可用】强制重新加载和渲染整个聊天界面。
     *              在你对聊天状态做了大量底层修改后，可以使用此函数来确保UI同步。
     */
    reloadCurrentChat,

    // -----------------------------------------------------------------------------
    // 持久化 API
    // -----------------------------------------------------------------------------

    /**
     * @function saveChatConditional
     * @description (!!!) 保存当前的聊天记录到文件。
     */
    saveChatConditional,

    // -----------------------------------------------------------------------------
    // 模板与工具 API
    // -----------------------------------------------------------------------------

    /**
     * @function renderExtensionTemplateAsync
     * @description 【UI】异步加载并渲染插件的HTML模板文件。
     */
    renderExtensionTemplateAsync,

    /**
     * @function substituteParams
     * @description 【未来可用】替换字符串中的宏，如 {{user}}, {{char}}。
     */
    substituteParams,

    /**
     * @function getTokenCountAsync
     * @description 【未来可用】异步计算给定字符串的token数量。对于需要管理上下文长度的插件至关重要。
     */
    getTokenCountAsync,
};


/**
 * @namespace USER
 * @description 用户数据管理器 (USER): 专门处理本插件的设置，提供优雅的读取和保存接口。
 */
export const USER = {
    /**
     * @property {object} settings
     * @description 一个Proxy对象，用于访问插件设置。
     *              它会自动处理从SillyTavern的`extension_settings`中读取数据，
     *              并在找不到值时回退到`defaultSettings`。
     * @example const isEnabled = USER.settings.isEnabled;
     * @example USER.settings.demoString = "New value"; // 这会自动触发保存
     */
    settings: new Proxy({}, {
        get(_, property) {
            const settings = extension_settings.Hevno_settings;
            if (settings && property in settings) {
                return settings[property];
            }
            return defaultSettings[property];
        },
        set(_, property, value) {
            if (!extension_settings.Hevno_settings) {
                extension_settings.Hevno_settings = {};
            }
            extension_settings.Hevno_settings[property] = value;
            saveSettingsDebounced();
            return true;
        },
    }),

    /**
     * @function saveSettings
     * @description 手动触发一次设置保存（带防抖）。通常不需要手动调用，因为`USER.settings`的set操作会自动保存。
     */
    saveSettings: saveSettingsDebounced,
};


/**
 * @namespace EDITOR
 * @description 编辑器/UI管理器 (EDITOR): 封装与SillyTavern UI组件的交互，如弹窗。
 */
export const EDITOR = {
    Popup,
    POPUP_TYPE,
    callGenericPopup,
};


/**
 * @namespace SYSTEM
 * @description 系统工具管理器 (SYSTEM): 封装插件的系统级操作，主要是资源加载。
 */
export const SYSTEM = {
    /**
     * @function getTemplate
     * @description 加载位于插件 `assets/templates` 目录下的HTML模板。
     * @param {string} name - HTML文件名（不含.html后缀）。
     * @returns {Promise<string>} HTML内容的字符串。
     * @example const settingsHtml = await SYSTEM.getTemplate('settings');
     */
    getTemplate: (name) => {
        // 注意：这里的路径是相对于 /public/extensions/ 目录的。
        // 如果你的插件文件夹是 Hevno，并且位于 third-party 子目录，路径就是 'third-party/Hevno/...'
        return APP.renderExtensionTemplateAsync('third-party/Hevno/assets/templates', name);
    },
};
```

### core/apiKeyManager.js
```
// src/core/apiKeyManager.js

import { USER } from './manager.js';

class ApiKeyManager {
    constructor() {
        this.keys = [];
        this.busyKeys = new Set();
        this.lastUsedIndex = -1;
    }

    /**
     * 从用户设置加载或刷新API密钥列表。
     */
    loadKeys() {
        const userKeys = USER.settings.geminiApiKeys || [];
        this.keys = userKeys.filter(key => key && key.trim() !== ''); // 过滤掉空密钥
        console.log(`[ApiKeyManager] Loaded ${this.keys.length} Gemini API keys.`);
    }

    /**
     * 获取一个可用的API密钥。
     * 实现简单的轮询和负载均衡。
     * @returns {string} 可用的API密钥。
     * @throws {Error} 如果没有可用的密钥。
     */
    acquireKey() {
        if (this.keys.length === 0) {
            throw new Error("No Gemini API keys are configured.");
        }
        if (this.busyKeys.size >= this.keys.length) {
            throw new Error("All Gemini API keys are currently in use. Please wait.");
        }

        // 轮询查找下一个可用密钥
        for (let i = 0; i < this.keys.length; i++) {
            this.lastUsedIndex = (this.lastUsedIndex + 1) % this.keys.length;
            const key = this.keys[this.lastUsedIndex];
            if (!this.busyKeys.has(key)) {
                this.busyKeys.add(key);
                console.log(`[ApiKeyManager] Acquired key ending in ...${key.slice(-4)}`);
                return key;
            }
        }
        
        // 理论上不应该到达这里，因为前面已经检查过 busyKeys.size
        throw new Error("Failed to acquire a key despite some being available. Concurrency issue?");
    }

    /**
     * 释放一个API密钥，使其可用于其他调用。
     * @param {string} key 要释放的API密钥。
     */
    releaseKey(key) {
        if (key && this.busyKeys.has(key)) {
            this.busyKeys.delete(key);
            console.log(`[ApiKeyManager] Released key ending in ...${key.slice(-4)}`);
        }
    }
}

// 导出单例，确保整个插件共享同一个密钥管理器
export const apiKeyManager = new ApiKeyManager();
```

### core/orchestrator.js
```
// src/core/orchestrator.js 

import { dispatch as dispatchLLM } from './llm_dispatcher.js';
import { APP } from './manager.js';

/**
 * @class GenerationOrchestrator
 * @description 模块化生成流程的编排与执行引擎。
 *              通过解析prompt中的 {{outputs.*}} 占位符自动推断模块依赖，并支持丰富的SillyTavern上下文变量。
 */
export class GenerationOrchestrator {
    /**
     * @param {Array<object>} pipelineDefinition - 包含所有模块定义的数组。
     * @param {object} initialSillyTavernContext - 从 `APP.getContext()` 获取的原始上下文。
     */
    constructor(pipelineDefinition, initialSillyTavernContext) {
        this.pipeline = pipelineDefinition.filter(m => m.enabled);
        
        const context = initialSillyTavernContext;
        const mainCharacter = (context.characterId !== -1 && context.characters && context.characters[context.characterId]) 
                              ? context.characters[context.characterId] 
                              : null;

        // 【增强点】构建一个更丰富的初始上下文，包含SillyTavern的常用数据
        this.initialContext = {
            sillyTavern: {
                chat: context.chat,
                character: mainCharacter,
                userInput: context.chat.slice(-1)[0]?.mes || '',
                userName: context.name1,
                // 新增：直接暴露更多有用信息
                worldInfo: context.worldInfo,
                authorsNote: context.authorsNote,
                charGreeting: mainCharacter?.first_mes || '',
            },
            // 用于存储各个模块的输出
            outputs: {}, 
        };

        console.log('[DEBUG] Orchestrator constructed its enriched initialContext:', this.initialContext);
        
        // 【可配置】指定哪个模块的输出是整个管线的最终结果
        this.finalOutputModuleId = 'final_formatter'; 
    }

    /**
     * 将聊天历史数组格式化为LLM可读的文本。
     * @param {Array<object>} chatArray - SillyTavern的聊天对象数组。
     * @returns {string} 格式化后的对话字符串。
     */
    _formatChatHistory(chatArray) {
        if (!Array.isArray(chatArray)) return '';
        return chatArray.map(message => {
            const prefix = message.is_user 
                ? (this.initialContext.sillyTavern.userName || 'User') 
                : (this.initialContext.sillyTavern.character?.name || 'Assistant');
            return `${prefix}: ${message.mes}`;
        }).join('\n');
    }

    /**
     * 【新增】格式化世界信息（World Info），使其更适合注入Prompt。
     * @param {Array<object>} worldInfoArray - SillyTavern的世界信息数组。
     * @returns {string} 格式化后的世界信息字符串。
     */
    _formatWorldInfo(worldInfoArray) {
        if (!Array.isArray(worldInfoArray)) return '';
        return worldInfoArray
            .filter(entry => entry.enabled) // 只使用启用的条目
            .map(entry => `[关键字: ${entry.key}]\n${entry.content}`)
            .join('\n\n---\n\n');
    }

    /**
     * 根据路径从上下文中解析模板变量的值。
     * @param {string} path - 点分隔的路径，例如 'sillyTavern.character.name'。
     * @returns {*} 解析出的值，如果路径无效则返回undefined。
     */
    _resolvePath(path) {
        let current = this.initialContext;
        const parts = path.split('.');
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (current && typeof current === 'object' && part in current) {
                current = current[part];
            } else {
                console.warn(`[Orchestrator] Path resolution failed. Key "${part}" not found in context for path "${path}".`);
                return undefined;
            }
        }
        console.log(`[DEBUG] _resolvePath: Resolved "${path}" successfully.`);
        return current;
    }

    /**
     * 渲染一个模块的prompt模板。
     * @param {object} module - 模块定义。
     * @returns {string} 渲染后的完整prompt字符串。
     */
    _renderPrompt(module) {
        let fullPrompt = '';
        for (const slot of module.promptSlots) {
            if (slot.enabled) {
                const renderedContent = slot.content.replace(/{{(.*?)}}/g, (match, path) => {
                    const trimmedPath = path.trim();
                    const value = this._resolvePath(trimmedPath);

                    if (value === undefined || value === null) {
                        console.warn(`[Orchestrator] Template variable "{{${trimmedPath}}}" resolved to undefined/null. Keeping original placeholder.`);
                        return match; 
                    }
                    
                    // 【增强点】使用专门的格式化函数处理特定数据类型
                    if (trimmedPath === 'sillyTavern.chat') {
                        return this._formatChatHistory(value);
                    }
                    if (trimmedPath === 'sillyTavern.worldInfo') {
                        return this._formatWorldInfo(value);
                    }
                    
                    if (typeof value === 'object' && !Array.isArray(value)) {
                        return JSON.stringify(value, null, 2);
                    }
                    return String(value);
                });
                fullPrompt += renderedContent + '\n';
            }
        }
        return fullPrompt.trim();
    }
    
    /**
     * 执行单个模块的逻辑。
     * @param {object} module - 要执行的模块定义。
     * @returns {Promise<{id: string, result: string}>} 包含模块ID和结果的对象。
     */
    async _executeModule(module) {
        console.log(`[Hevno Orchestrator] Executing module: ${module.id} (${module.name})`);
        const finalPrompt = this._renderPrompt(module);
        
        console.log(`[Hevno Orchestrator] === START RENDERED PROMPT for ${module.id} ===\n${finalPrompt}\n=== END RENDERED PROMPT for ${module.id} ===`);

        // ======================= 【核心修改点】 =======================
        // 移除了模拟逻辑，替换为真实的、可分派的LLM调用。
        let result;
        try {
            toastr.info(`Running module: ${module.name}...`, "Hevno Pipeline");
            result = await dispatchLLM(finalPrompt, module.llm);
            toastr.success(`Module "${module.name}" completed!`, "Hevno Pipeline");
        } catch (error) {
            console.error(`[Hevno Orchestrator] Failed to execute module ${module.id}:`, error);
            toastr.error(`Error in module "${module.name}": ${error.message}`, "Pipeline Error");
            // 抛出错误以中止整个管线执行
            throw error;
        }
        // =============================================================

        console.log(`[Hevno Orchestrator] Finished module: ${module.id}. Result stored.`);
        this.initialContext.outputs[module.id] = result;
        return { id: module.id, result };
    }

    _extractDependencies(module) {
        const dependencies = new Set();
        const dependencyRegex = /{{\s*outputs\.([\w_]+)\s*}}/g;
        for (const slot of (module.promptSlots || [])) {
            if (slot.enabled && slot.content) {
                const matches = slot.content.matchAll(dependencyRegex);
                for (const match of matches) {
                    dependencies.add(match[1]);
                }
            }
        }
        return dependencies;
    }

    async run() {
        console.log('[Hevno Orchestrator] Starting pipeline run with automatic dependency detection...');
        const dependencyGraph = new Map();
        const reverseDependencyGraph = new Map();
        const inDegree = new Map();

        for (const module of this.pipeline) {
            const dependencies = this._extractDependencies(module);
            dependencyGraph.set(module.id, dependencies);
            inDegree.set(module.id, dependencies.size);
            if (!reverseDependencyGraph.has(module.id)) {
                reverseDependencyGraph.set(module.id, new Set());
            }
            for (const dep of dependencies) {
                if (!reverseDependencyGraph.has(dep)) reverseDependencyGraph.set(dep, new Set());
                reverseDependencyGraph.get(dep).add(module.id);
            }
        }

        let executionQueue = this.pipeline.filter(m => inDegree.get(m.id) === 0);
        while (executionQueue.length > 0) {
            console.log(`[Hevno Orchestrator] Executing parallel batch of ${executionQueue.length} modules:`, executionQueue.map(m => m.id));
            const promises = executionQueue.map(module => this._executeModule(module));
            const results = await Promise.all(promises);
            const nextExecutionQueue = [];
            for (const { id } of results) {
                const dependents = reverseDependencyGraph.get(id) || [];
                for (const dependentId of dependents) {
                    const newDegree = inDegree.get(dependentId) - 1;
                    inDegree.set(dependentId, newDegree);
                    if (newDegree === 0) {
                        nextExecutionQueue.push(this.pipeline.find(m => m.id === dependentId));
                    }
                }
            }
            executionQueue = nextExecutionQueue;
        }

        const unexecutedModules = this.pipeline.filter(m => !(m.id in this.initialContext.outputs));
        if (unexecutedModules.length > 0) {
            const unexecutedIds = unexecutedModules.map(m => m.id).join(', ');
            throw new Error(`Execution failed. A circular dependency may exist. Unexecuted modules: ${unexecutedIds}`);
        }
        
        console.log("[Hevno Orchestrator] Pipeline finished. All outputs:", this.initialContext.outputs);

        // 【改进点】返回指定最终模块的真实（模拟）输出
        const finalOutput = this.initialContext.outputs[this.finalOutputModuleId];
        if (finalOutput) {
            console.log(`[Hevno Orchestrator] Returning final output from module: ${this.finalOutputModuleId}`);
            return finalOutput;
        }

        console.warn(`[Hevno Orchestrator] Pipeline completed, but the designated final output module "${this.finalOutputModuleId}" did not produce a result.`);
        return "Pipeline completed, but no final output was designated.";
    }
}
```

### data/defaultPipeline.js
```
// src/data/defaultPipeline.js (已更新以适配新的LLM调度器)

export const defaultPipeline = [
    {
        "id": "stage_setter",
        "name": "场景与背景设定器",
        "enabled": true,
        "llm": {
            "provider": "gemini",
            "model": "gemini-2.5-flash",
            "temperature": 0.8,
            "maxOutputTokens": 1024
        },
        "promptSlots": [
            {
                "id": "task_description",
                "enabled": true,
                "content": "你是一个场景导演。根据以下信息，生成一段充满氛围的开场白，为接下来的故事奠定基调。"
            },
            {
                "id": "character_info",
                "enabled": true,
                "content": `
# 角色核心设定
{{sillyTavern.character.description}}

# 角色性格
{{sillyTavern.character.personality}}

# 作者笔记/全局指令
{{sillyTavern.authorsNote}}
                `
            },
            {
                "id": "world_info",
                "enabled": true,
                "content": `
# 世界观与关键信息
{{sillyTavern.worldInfo}}
                `
            }
        ]
    },
    {
        "id": "history_summarizer",
        "name": "历史摘要器",
        "enabled": true,
        "llm": {
            "provider": "gemini",
            "model": "gemini-2.5-flash",
            "temperature": 0.3,
            "maxOutputTokens": 512
        },
        "promptSlots": [
            {
                "id": "summarize_task",
                "enabled": true,
                "content": "将以下对话历史浓缩成一段简洁的摘要，不超过200字，捕捉核心情节和人物情绪。"
            },
            {
                "id": "chat_history",
                "enabled": true,
                "content": "{{sillyTavern.chat}}"
            }
        ]
    },
    {
        "id": "main_story_generator",
        "name": "主故事生成器",
        "enabled": true,
        "llm": {
            "provider": "gemini",
            "model": "gemini-2.5-flash",
            "temperature": 0.9,
            "maxOutputTokens": 2048
        },
        "promptSlots": [
            {
                "id": "combined_context",
                "enabled": true,
                "content": `
# 场景与基调
{{outputs.stage_setter}}

# 历史回顾
{{outputs.history_summarizer}}

请基于以上背景，并以前次对话的风格，继续下面的故事。
                `
            },
            {
                "id": "user_latest_input",
                "enabled": true,
                "content": "{{sillyTavern.userInput}}"
            }
        ]
    },
    {
        "id": "style_enhancer",
        "name": "文笔润色器",
        "enabled": true,
        "llm": {
            "provider": "gemini",
            "model": "gemini-2.5-flash",
            "temperature": 0.7,
            "maxOutputTokens": 2048
        },
        "promptSlots": [
            {
                "id": "style_task",
                "enabled": true,
                "content": "你是一位文学大师。请将以下文本用更具诗意和表现力的语言重写，但保持原意不变。"
            },
            {
                "id": "original_text",
                "enabled": true,
                "content": "{{outputs.main_story_generator}}"
            }
        ]
    },
    {
        "id": "emotion_detector",
        "name": "情绪分析器",
        "enabled": true,
        "llm": {
            "provider": "gemini",
            "model": "gemini-2.5-flash",
            "temperature": 0.1,
            "maxOutputTokens": 64
        },
        "promptSlots": [
            {
                "id": "emotion_task",
                "enabled": true,
                "content": "分析以下文本中表达的主要情绪。用一个词回答，例如：喜悦、悲伤、愤怒、惊讶、平静。"
            },
            {
                "id": "text_to_analyze",
                "enabled": true,
                "content": "{{outputs.main_story_generator}}"
            }
        ]
    },
    {
        "id": "final_formatter",
        "name": "最终格式化模块",
        "enabled": true,
        "llm": {
            "provider": "gemini",
            "model": "gemini-2.5-flash",
            "temperature": 0.1,
            "maxOutputTokens": 4096 // 留有足够空间组合所有内容
        },
        "promptSlots": [
            {
                "id": "format_task",
                "enabled": true,
                "content": "你是一个格式化助手。将主文本和情绪标签组合成最终的输出。格式如下：\n[角色当前情绪：<情绪标签>]\n\n<主文本>"
            },
            {
                "id": "final_content",
                "enabled": true,
                "content": `
情绪标签：{{outputs.emotion_detector}}
主文本：{{outputs.style_enhancer}}
                `
            }
        ]
    }
];
```

### data/pluginSetting.js
```
import { defaultPipeline } from './defaultPipeline.js';

export const defaultSettings = {
    isEnabled: true,
    demoString: "This message was intercepted and replaced by the Hevno plugin.",
    pipeline: defaultPipeline, 
    geminiApiKeys: [],
};
```

### scripts/settings/userExtensionSetting.js
```
// src/scripts/settings/userExtensionSetting.js

import { USER } from '../../core/manager.js';
import { apiKeyManager } from '../../core/apiKeyManager.js';

/**
 * 验证导入的管线对象是否具有基本结构。
 * @param {any} data - 从JSON文件解析出的数据。
 * @returns {boolean} - 如果数据结构有效则返回true。
 */
function isValidPipeline(data) {
    if (!Array.isArray(data)) {
        toastr.error("Invalid pipeline: The file content is not an array.", "Import Error");
        return false;
    }
    if (data.length === 0) {
        toastr.warning("Imported pipeline is empty.", "Import Warning");
        return true; // 空管线是有效的
    }
    const firstModule = data[0];
    if (typeof firstModule !== 'object' || firstModule === null || !('id' in firstModule) || !('name' in firstModule) || !('promptSlots' in firstModule)) {
        toastr.error("Invalid pipeline: Modules are missing required properties (id, name, promptSlots).", "Import Error");
        return false;
    }
    return true;
}

/**
 * 【新增】处理管线导出逻辑。
 */
function handleExportPipeline() {
    try {
        const currentPipeline = USER.settings.pipeline;
        const jsonString = JSON.stringify(currentPipeline, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        
        // 创建一个临时的下载链接
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `hevno-pipeline-${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a);
        a.click();
        
        // 清理
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        toastr.success("Pipeline exported successfully!", "Export Complete");
    } catch (error) {
        console.error("[Hevno] Failed to export pipeline:", error);
        toastr.error("An error occurred while exporting the pipeline.", "Export Error");
    }
}

/**
 * 【新增】处理文件选择和管线导入逻辑。
 * @param {Event} event - 文件输入框的change事件。
 */
function handleImportPipeline(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const content = e.target.result;
            const importedPipeline = JSON.parse(content);

            if (isValidPipeline(importedPipeline)) {
                // 验证通过，保存到设置中
                // USER.settings的Proxy会自动调用saveSettingsDebounced()
                USER.settings.pipeline = importedPipeline;
                toastr.success("Pipeline imported and saved successfully!", "Import Complete");
            }
        } catch (error) {
            console.error("[Hevno] Failed to import pipeline:", error);
            toastr.error(`Failed to read or parse the pipeline file: ${error.message}`, "Import Error");
        } finally {
            // 重置文件输入框，以便可以再次选择同一个文件
            event.target.value = '';
        }
    };
    reader.onerror = () => {
        toastr.error("Failed to read the selected file.", "File Read Error");
    };

    reader.readAsText(file);
}

/**
 * 渲染设置界面的当前值
 */
function renderSettings() {
    $('#Hevno_enabled_switch').prop('checked', USER.settings.isEnabled);
    $('#Hevno_demo_string_input').val(USER.settings.demoString);

    const keys = USER.settings.geminiApiKeys || [];
    $('#hevno_gemini_keys_textarea').val(keys.join('\n'));
}

/**
 * 绑定UI元素的事件监听
 */
function bindEvents() {
    // 原有事件
    $('#Hevno_enabled_switch').on('change', function() {
        USER.settings.isEnabled = $(this).is(':checked');
    });
    $('#Hevno_demo_string_input').on('input', function() {
        USER.settings.demoString = $(this).val();
    });

    // 【新增】为新按钮和文件输入框绑定事件
    $('#hevno_export_pipeline_btn').on('click', handleExportPipeline);
    
    // 点击“导入”按钮时，实际触发隐藏的文件输入框
    $('#hevno_import_pipeline_btn').on('click', () => {
        $('#hevno_pipeline_file_input').click();
    });

    // 当用户选择了文件后，处理文件内容
    $('#hevno_pipeline_file_input').on('change', handleImportPipeline);

        $('#hevno_gemini_keys_textarea').on('input', function() {
        const keysString = $(this).val();
        const keysArray = keysString.split('\n').map(k => k.trim()).filter(k => k);
        USER.settings.geminiApiKeys = keysArray;
        // 立即通知密钥管理器更新其密钥池
        apiKeyManager.loadKeys();
    });
}

/**
 * 加载设置的主函数
 */
export function loadSettings() {
    renderSettings();
    bindEvents();
    apiKeyManager.loadKeys();
    console.log("[Hevno] Settings UI loaded and pipeline management events bound.");
}
```
