### index.js
```
// src/index.js (附有详细注释文档)

/**
 * @file index.js
 * @description 插件的主入口文件。
 * @version 1.1.0
 *
 * @summary
 * 该文件负责插件的初始化，包括：
 * 1.  向SillyTavern页面注入插件的设置UI。
 * 2.  注册核心的生成拦截器 `HevnoInterceptor`，这是插件所有功能的核心。
 *
 * 【新开发者必读】
 * 插件的生命周期从 `jQuery(async () => { ... });` 开始，这确保了代码在页面DOM加载完毕后执行。
 * 核心逻辑位于 `globalThis.HevnoInterceptor` 函数中，请务必理解其工作流程。
 */

import { APP, USER, SYSTEM } from './core/manager.js';
import { loadSettings } from './scripts/settings/userExtensionSetting.js';

console.log("______________________ Hevno Plugin: Loading ______________________");

/**
 * @function HevnoInterceptor
 * @global
 * @description (!!!) 插件的核心 - 生成拦截器。
 *
 * 【关键概念：生成拦截器 (Generation Interceptor)】
 * 这是通过 `manifest.json`中的 `generate_interceptor` 字段注册到SillyTavern的全局函数。
 * 在SillyTavern每次准备向LLM发送请求之前，它会“暂停”并调用这个函数，给予插件干预的机会。
 *
 * 【核心工作流：拦截 -> 执行 -> 喂回】
 * 这个函数的设计遵循了一个健壮的模式，以确保与SillyTavern的深度和安全集成：
 * 1.  **拦截 (Intercept)**: 通过调用 `abort(true)`，我们立即中止SillyTavern的默认生成流程，完全接管控制权。
 * 2.  **执行 (Execute)**: 这是我们插件自定义逻辑的执行阶段。在这里，我们可以进行自己的LLM调用、
 *     数据处理，或者像这个例子一样，简单地准备一个固定的字符串。
 * 3.  **喂回 (Feed-back)**: 我们不直接操作DOM，而是将我们的最终结果通过 `APP.saveReply()` 函数
 *     “喂回”给SillyTavern。SillyTavern会像处理一个真实的AI回复一样，负责后续所有的UI渲染、
 *     事件触发和状态更新。这是最推荐的集成方式。
 * 4.  **清理 (Cleanup)**: 在 `finally` 块中，必须调用 `APP.unblockGeneration()` 来解锁UI，
 *     无论流程成功与否，这都能防止界面卡死。
 *
 * @param {Array} chat - 即将用于构建prompt的聊天历史数组（在此模式下我们通常不直接修改它）。
 * @param {Number} contextSize - 当前的token计数。
 * @param {Function} abort - 中止函数。调用 `abort(true)` 来中止并阻止其他拦截器运行。
 * @param {String} type - 触发生成的类型 (e.g., 'send', 'regenerate', 'swipe')。
 */
globalThis.HevnoInterceptor = async function(chat, contextSize, abort, type) {
    const settings = USER.settings;

    // 步骤 0: 前置检查。如果插件被禁用，则直接返回，让SillyTavern继续正常流程。
    if (!settings.isEnabled) {
        return;
    }

    console.log(`[Hevno] Intercepting generation of type: ${type}`);

    // 步骤 1: 【拦截】中止SillyTavern的原始生成流程。
    abort(true);

    try {
        // 步骤 2: 【执行】执行插件的自定义逻辑。
        // 在这个简单的雏形中，我们只是从设置里获取一个字符串。
        // 在未来的复杂插件中，这里可以替换为对 `APP.generateRaw()` 的多次调用和结果处理。
        const finalOutput = settings.demoString;

        if (!finalOutput) {
            console.warn("[Hevno] Demo string is empty, nothing to generate.");
            return;
        }

        // 步骤 3: 【喂回】将结果交给SillyTavern的核心处理函数。
        // `saveReply` 会负责创建消息、渲染UI、触发事件等所有后续工作。
        await APP.saveReply({
            type: 'normal',
            getMessage: finalOutput,
            title: 'Generated by Hevno Plugin',
        });

        // 步骤 4: 【持久化】调用SillyTavern的保存函数来保存新的聊天记录。
        await APP.saveChatConditional();

        console.log(`[Hevno] Generation aborted and replaced with demo message via saveReply.`);

    } catch (error) {
        console.error("[Hevno] An error occurred during the interception process:", error);
        toastr.error("The Hevno Plugin encountered an error.", "Plugin Error");
    } finally {
        // 步骤 5: 【清理】(!!!) 关键步骤！无论成功还是失败，都必须调用此函数来解锁UI。
        APP.unblockGeneration(type);
    }
};

/**
 * 插件的主初始化函数。
 * 使用 jQuery(async () => { ... }) 确保在文档对象模型(DOM)完全加载和解析完毕后执行。
 * 这是Web开发的标准实践，可以防止因尝试操作不存在的元素而导致的错误。
 */
jQuery(async () => {
    // 任务1: 注入插件的设置UI界面。
    try {
        // 使用我们封装的 SYSTEM 管理器来异步加载HTML模板。
        const settingsHtml = await SYSTEM.getTemplate('settings');

        // 使用jQuery将加载的HTML内容附加到SillyTavern的扩展设置面板中。
        // '#extensions_settings' 是SillyTavern中用于放置所有插件设置的容器ID。
        $('#extensions_settings').append(settingsHtml);

        // 加载设置的初始值并为UI元素绑定事件监听器。
        loadSettings();

    } catch (error) {
        console.error("[Hevno] Failed to load settings UI.", error);
    }
    
    console.log("______________________ Hevno Plugin: Loaded Successfully ______________________");
});
```

### core/manager.js
```
// src/core/manager.js (附有详细注释文档)

/**
 * @file manager.js
 * @description 插件的核心管理器和API抽象层。
 * @version 1.1.0
 *
 * @see README.md - 插件的整体架构设计。
 *
 * @summary
 * 这个文件是插件与SillyTavern进行交互的唯一桥梁。它将SillyTavern复杂、有时甚至是全局的API
 * 封装成一组逻辑清晰、易于管理的单例对象（APP, USER, EDITOR, SYSTEM）。
 *
 * 【新开发者必读】
 * 任何与SillyTavern的直接交互（如调用函数、获取数据）都应该首先在这里进行封装。
 * 插件的其他部分（如index.js）应优先调用这里的管理器，而不是直接触碰SillyTavern的API。
 * 这种设计模式（称为“外观模式”或“适配器模式”）有以下好处：
 * 1.  **解耦**: 插件的业务逻辑与SillyTavern的实现细节分离。
 * 2.  **可维护性**: 如果SillyTavern未来更新了API，我们只需要修改这个文件，而不用改动整个插件。
 * 3.  **清晰性**: 提供了清晰的API边界，新开发者能快速了解插件可用的所有SillyTavern功能。
 */

// ===================================================================================
// I. 导入SillyTavern的核心功能
// ===================================================================================
// 注意: 导入路径是相对于SillyTavern的 /public/ 目录的。

// 从 /script.js 导入SillyTavern的核心功能函数。
// 这些函数大多是经过 `export` 关键字明确导出的“公共API”。
import {
    // 事件系统
    eventSource,
    event_types,
    // 设置与持久化
    saveSettingsDebounced,
    // 核心消息处理 (!!!)
    saveReply,
    saveChatConditional,
    activateSendButtons,
    // 其他常用工具
    addOneMessage,
    deleteLastMessage,
    generateRaw,
    reloadCurrentChat,
    sendSystemMessage,
    substituteParams,
    
} from '/script.js';

import {getTokenCountAsync} from '/scripts/tokenizers.js'; // 异步计算token数量的函数

// 从 /scripts/extensions.js 导入专门为插件提供的功能。
import { getContext, extension_settings, renderExtensionTemplateAsync } from '/scripts/extensions.js';
// 从 /scripts/popup.js 导入UI组件。
import { Popup, POPUP_TYPE, callGenericPopup } from '/scripts/popup.js';

// 导入插件自身的默认设置，作为回退方案。
import { defaultSettings } from '../data/pluginSetting.js';


// ===================================================================================
// II. 定义和导出管理器
// ===================================================================================

/**
 * @namespace APP
 * @description 应用管理器 (APP): 封装与SillyTavern应用本身交互的核心API。
 *              这是最常用的管理器，提供了对SillyTavern状态和核心流程的访问。
 */
export const APP = {
    // -----------------------------------------------------------------------------
    // 核心上下文与数据 API
    // -----------------------------------------------------------------------------

    /**
     * @function getContext
     * @description (!!!) 获取SillyTavern的全局上下文对象。这是访问所有运行时数据的入口。
     * @returns {object} 上下文对象，包含 chat, characters, settings, eventSource 等。
     * @see https://docs.sillytavern.app/extensions/api/context/
     */
    getContext,

    // -----------------------------------------------------------------------------
    // 事件系统 API
    // -----------------------------------------------------------------------------

    /**
     * @property {EventEmitter} eventSource
     * @description SillyTavern的事件发射器，用于监听应用内的各种事件。
     * @example APP.eventSource.on(APP.event_types.MESSAGE_RECEIVED, (messageId) => { ... });
     */
    eventSource,

    /**
     * @property {object} event_types
     * @description 一个包含所有可用事件名称的枚举对象。
     * @see https://docs.sillytavern.app/extensions/api/events/
     */
    event_types,

    // -----------------------------------------------------------------------------
    // 消息处理与生成流程控制 API
    // -----------------------------------------------------------------------------

    /**
     * @function saveReply
     * @description (!!!) 【推荐】将一个字符串作为AI回复注入SillyTavern的完整消息处理流程。
     *              这是实现“喂回”机制的核心，比 addOneMessage 更健壮。
     * @param {object} options - 包含回复信息的对象。
     * @example await APP.saveReply({ type: 'normal', getMessage: '你好！' });
     */
    saveReply,

    /**
     * @function activateSendButtons
     * @description (!!!) 【关键】解锁UI，重新启用发送按钮。在拦截并中止生成后，必须在finally块中调用此函数。
     *              这是 unblockGeneration 的安全、公共的替代品。
     */
    unblockGeneration: activateSendButtons,

    /**
     * @function generateRaw
     * @description 【未来可用】在后台静默发起一次LLM调用，不影响当前聊天界面。
     *              对于需要LLM进行数据处理的复杂插件（如摘要、翻译）非常有用。
     * @param {string} prompt - 要发送给LLM的提示。
     * @returns {Promise<string>} LLM生成的文本。
     */
    generateRaw,

    // -----------------------------------------------------------------------------
    // 聊天记录操作 API
    // -----------------------------------------------------------------------------

    /**
     * @function addOneMessage
     * @description 【未来可用】将一个标准格式的消息对象直接渲染到聊天界面。
     *              主要用于添加非AI生成的、系统性的消息。对于AI回复，应优先使用 saveReply。
     * @param {object} messageObject - 符合SillyTavern格式的消息对象。
     */
    addOneMessage,

    /**
     * @function sendSystemMessage
     * @description 【未来可用】一个更高级的函数，用于方便地发送格式化的系统消息。
     * @param {string} type - 系统消息类型, e.g., 'generic', 'comment'。
     * @param {string} text - 消息内容。
     */
    sendSystemMessage,

    /**
     * @function deleteLastMessage
     * @description 【未来可用】删除聊天记录中的最后一条消息。
     */
    deleteLastMessage,

    /**
     * @function reloadCurrentChat
     * @description 【未来可用】强制重新加载和渲染整个聊天界面。
     *              在你对聊天状态做了大量底层修改后，可以使用此函数来确保UI同步。
     */
    reloadCurrentChat,

    // -----------------------------------------------------------------------------
    // 持久化 API
    // -----------------------------------------------------------------------------

    /**
     * @function saveChatConditional
     * @description (!!!) 保存当前的聊天记录到文件。
     */
    saveChatConditional,

    // -----------------------------------------------------------------------------
    // 模板与工具 API
    // -----------------------------------------------------------------------------

    /**
     * @function renderExtensionTemplateAsync
     * @description 【UI】异步加载并渲染插件的HTML模板文件。
     */
    renderExtensionTemplateAsync,

    /**
     * @function substituteParams
     * @description 【未来可用】替换字符串中的宏，如 {{user}}, {{char}}。
     */
    substituteParams,

    /**
     * @function getTokenCountAsync
     * @description 【未来可用】异步计算给定字符串的token数量。对于需要管理上下文长度的插件至关重要。
     */
    getTokenCountAsync,
};


/**
 * @namespace USER
 * @description 用户数据管理器 (USER): 专门处理本插件的设置，提供优雅的读取和保存接口。
 */
export const USER = {
    /**
     * @property {object} settings
     * @description 一个Proxy对象，用于访问插件设置。
     *              它会自动处理从SillyTavern的`extension_settings`中读取数据，
     *              并在找不到值时回退到`defaultSettings`。
     * @example const isEnabled = USER.settings.isEnabled;
     * @example USER.settings.demoString = "New value"; // 这会自动触发保存
     */
    settings: new Proxy({}, {
        get(_, property) {
            const settings = extension_settings.Hevno_settings;
            if (settings && property in settings) {
                return settings[property];
            }
            return defaultSettings[property];
        },
        set(_, property, value) {
            if (!extension_settings.Hevno_settings) {
                extension_settings.Hevno_settings = {};
            }
            extension_settings.Hevno_settings[property] = value;
            saveSettingsDebounced();
            return true;
        },
    }),

    /**
     * @function saveSettings
     * @description 手动触发一次设置保存（带防抖）。通常不需要手动调用，因为`USER.settings`的set操作会自动保存。
     */
    saveSettings: saveSettingsDebounced,
};


/**
 * @namespace EDITOR
 * @description 编辑器/UI管理器 (EDITOR): 封装与SillyTavern UI组件的交互，如弹窗。
 */
export const EDITOR = {
    Popup,
    POPUP_TYPE,
    callGenericPopup,
};


/**
 * @namespace SYSTEM
 * @description 系统工具管理器 (SYSTEM): 封装插件的系统级操作，主要是资源加载。
 */
export const SYSTEM = {
    /**
     * @function getTemplate
     * @description 加载位于插件 `assets/templates` 目录下的HTML模板。
     * @param {string} name - HTML文件名（不含.html后缀）。
     * @returns {Promise<string>} HTML内容的字符串。
     * @example const settingsHtml = await SYSTEM.getTemplate('settings');
     */
    getTemplate: (name) => {
        // 注意：这里的路径是相对于 /public/extensions/ 目录的。
        // 如果你的插件文件夹是 Hevno，并且位于 third-party 子目录，路径就是 'third-party/Hevno/...'
        return APP.renderExtensionTemplateAsync('third-party/Hevno/assets/templates', name);
    },
};
```

### data/pluginSetting.js
```
export const defaultSettings = {
    isEnabled: true,
    demoString: "This message was intercepted and replaced by the Hevno plugin.",
};
```

### scripts/settings/userExtensionSetting.js
```
import { USER } from '../../core/manager.js';

/**
 * 渲染设置界面的当前值
 */
function renderSettings() {
    $('#Hevno_enabled_switch').prop('checked', USER.settings.isEnabled);
    $('#Hevno_demo_string_input').val(USER.settings.demoString);
}

/**
 * 绑定UI元素的事件监听
 */
function bindEvents() {
    // 插件总开关
    $('#Hevno_enabled_switch').on('change', function() {
        USER.settings.isEnabled = $(this).is(':checked');
    });

    // 演示字符串输入框
    $('#Hevno_demo_string_input').on('input', function() {
        USER.settings.demoString = $(this).val();
    });
}

/**
 * 加载设置的主函数
 */
export function loadSettings() {
    renderSettings();
    bindEvents();
    console.log("Hevno settings UI loaded and events bound.");
}
```
