### index.js
```
// src/index.js (é™„æœ‰è¯¦ç»†æ³¨é‡Šæ–‡æ¡£)

/**
 * @file index.js
 * @description æ’ä»¶çš„ä¸»å…¥å£æ–‡ä»¶ã€‚
 * @version 1.1.0
 *
 * @summary
 * è¯¥æ–‡ä»¶è´Ÿè´£æ’ä»¶çš„åˆå§‹åŒ–ï¼ŒåŒ…æ‹¬ï¼š
 * 1.  å‘SillyTaverné¡µé¢æ³¨å…¥æ’ä»¶çš„è®¾ç½®UIã€‚
 * 2.  æ³¨å†Œæ ¸å¿ƒçš„ç”Ÿæˆæ‹¦æˆªå™¨ `HevnoInterceptor`ï¼Œè¿™æ˜¯æ’ä»¶æ‰€æœ‰åŠŸèƒ½çš„æ ¸å¿ƒã€‚
 *
 * ã€æ–°å¼€å‘è€…å¿…è¯»ã€‘
 * æ’ä»¶çš„ç”Ÿå‘½å‘¨æœŸä» `jQuery(async () => { ... });` å¼€å§‹ï¼Œè¿™ç¡®ä¿äº†ä»£ç åœ¨é¡µé¢DOMåŠ è½½å®Œæ¯•åæ‰§è¡Œã€‚
 * æ ¸å¿ƒé€»è¾‘ä½äº `globalThis.HevnoInterceptor` å‡½æ•°ä¸­ï¼Œè¯·åŠ¡å¿…ç†è§£å…¶å·¥ä½œæµç¨‹ã€‚
 */

import { APP, USER, SYSTEM } from './core/manager.js';
import { loadSettings } from './scripts/settings/userExtensionSetting.js';
import { GenerationOrchestrator } from './core/orchestrator.js';
import { defaultPipeline } from './data/defaultPipeline.js';

console.log("______________________ Hevno Plugin: Loading ______________________");

/**
 * @function HevnoInterceptor
 * @global
 * @description (!!!) æ’ä»¶çš„æ ¸å¿ƒ - ç”Ÿæˆæ‹¦æˆªå™¨ã€‚
 *
 * ã€å…³é”®æ¦‚å¿µï¼šç”Ÿæˆæ‹¦æˆªå™¨ (Generation Interceptor)ã€‘
 * è¿™æ˜¯é€šè¿‡ `manifest.json`ä¸­çš„ `generate_interceptor` å­—æ®µæ³¨å†Œåˆ°SillyTavernçš„å…¨å±€å‡½æ•°ã€‚
 * åœ¨SillyTavernæ¯æ¬¡å‡†å¤‡å‘LLMå‘é€è¯·æ±‚ä¹‹å‰ï¼Œå®ƒä¼šâ€œæš‚åœâ€å¹¶è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œç»™äºˆæ’ä»¶å¹²é¢„çš„æœºä¼šã€‚
 *
 * ã€æ ¸å¿ƒå·¥ä½œæµï¼šæ‹¦æˆª -> æ‰§è¡Œ -> å–‚å›ã€‘
 * è¿™ä¸ªå‡½æ•°çš„è®¾è®¡éµå¾ªäº†ä¸€ä¸ªå¥å£®çš„æ¨¡å¼ï¼Œä»¥ç¡®ä¿ä¸SillyTavernçš„æ·±åº¦å’Œå®‰å…¨é›†æˆï¼š
 * 1.  **æ‹¦æˆª (Intercept)**: é€šè¿‡è°ƒç”¨ `abort(true)`ï¼Œæˆ‘ä»¬ç«‹å³ä¸­æ­¢SillyTavernçš„é»˜è®¤ç”Ÿæˆæµç¨‹ï¼Œå®Œå…¨æ¥ç®¡æ§åˆ¶æƒã€‚
 * 2.  **æ‰§è¡Œ (Execute)**: è¿™æ˜¯æˆ‘ä»¬æ’ä»¶è‡ªå®šä¹‰é€»è¾‘çš„æ‰§è¡Œé˜¶æ®µã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œè‡ªå·±çš„LLMè°ƒç”¨ã€
 *     æ•°æ®å¤„ç†ï¼Œæˆ–è€…åƒè¿™ä¸ªä¾‹å­ä¸€æ ·ï¼Œç®€å•åœ°å‡†å¤‡ä¸€ä¸ªå›ºå®šçš„å­—ç¬¦ä¸²ã€‚
 * 3.  **å–‚å› (Feed-back)**: æˆ‘ä»¬ä¸ç›´æ¥æ“ä½œDOMï¼Œè€Œæ˜¯å°†æˆ‘ä»¬çš„æœ€ç»ˆç»“æœé€šè¿‡ `APP.saveReply()` å‡½æ•°
 *     â€œå–‚å›â€ç»™SillyTavernã€‚SillyTavernä¼šåƒå¤„ç†ä¸€ä¸ªçœŸå®çš„AIå›å¤ä¸€æ ·ï¼Œè´Ÿè´£åç»­æ‰€æœ‰çš„UIæ¸²æŸ“ã€
 *     äº‹ä»¶è§¦å‘å’ŒçŠ¶æ€æ›´æ–°ã€‚è¿™æ˜¯æœ€æ¨èçš„é›†æˆæ–¹å¼ã€‚
 * 4.  **æ¸…ç† (Cleanup)**: åœ¨ `finally` å—ä¸­ï¼Œå¿…é¡»è°ƒç”¨ `APP.unblockGeneration()` æ¥è§£é”UIï¼Œ
 *     æ— è®ºæµç¨‹æˆåŠŸä¸å¦ï¼Œè¿™éƒ½èƒ½é˜²æ­¢ç•Œé¢å¡æ­»ã€‚
 *
 * @param {Array} chat - å³å°†ç”¨äºæ„å»ºpromptçš„èŠå¤©å†å²æ•°ç»„ï¼ˆåœ¨æ­¤æ¨¡å¼ä¸‹æˆ‘ä»¬é€šå¸¸ä¸ç›´æ¥ä¿®æ”¹å®ƒï¼‰ã€‚
 * @param {Number} contextSize - å½“å‰çš„tokenè®¡æ•°ã€‚
 * @param {Function} abort - ä¸­æ­¢å‡½æ•°ã€‚è°ƒç”¨ `abort(true)` æ¥ä¸­æ­¢å¹¶é˜»æ­¢å…¶ä»–æ‹¦æˆªå™¨è¿è¡Œã€‚
 * @param {String} type - è§¦å‘ç”Ÿæˆçš„ç±»å‹ (e.g., 'send', 'regenerate', 'swipe')ã€‚
 */
globalThis.HevnoInterceptor = async function (chat, contextSize, abort, type) {
    const settings = USER.settings;

    if (!settings.isEnabled) {
        return;
    }

    console.log(`[Hevno] Intercepting generation of type: ${type}`);
    abort(true);

    try {
        console.log("[Hevno] Starting modular generation pipeline...");

        // ã€ä¿®æ”¹ã€‘ä»ç”¨æˆ·è®¾ç½®ä¸­åŠ¨æ€è·å–ç®¡çº¿å®šä¹‰
        // USER.settings.pipeline ä¼šè‡ªåŠ¨ä»SillyTavernçš„å­˜å‚¨ä¸­è¯»å–ï¼Œ
        // å¦‚æœæ²¡æœ‰ï¼Œåˆ™å›é€€åˆ°æˆ‘ä»¬åœ¨ pluginSetting.js ä¸­å®šä¹‰çš„é»˜è®¤å€¼ã€‚
        const pipelineDefinition = USER.settings.pipeline;

        if (!pipelineDefinition || !Array.isArray(pipelineDefinition) || pipelineDefinition.length === 0) {
            toastr.error("Hevno pipeline is missing or invalid. Please import a valid pipeline in settings.", "Pipeline Error");
            console.error("[Hevno] No valid pipeline found in settings.");
            return;
        }

        const orchestrator = new GenerationOrchestrator(pipelineDefinition, APP.getContext());

        const finalOutput = await orchestrator.run();

        if (!finalOutput) {
            console.warn("[Hevno] Pipeline ran, but produced no final output.");
            // å³ä½¿æ²¡æœ‰è¾“å‡ºï¼Œä¹Ÿéœ€è¦ä¸€ä¸ªç©ºå›å¤æ¥å®Œæˆæµç¨‹
            await APP.saveReply({ type: 'normal', getMessage: '' });
        } else {
            await APP.saveReply({
                type: 'normal',
                getMessage: finalOutput,
                title: 'Generated by Hevno Modular Pipeline',
            });
        }

        await APP.saveChatConditional();

        console.log(`[Hevno] Generation completed via modular pipeline.`);

    } catch (error) {
        console.error("[Hevno] An error occurred during the modular pipeline execution:", error);
        toastr.error(`The Hevno Plugin encountered an error: ${error.message}`, "Pipeline Error");
    } finally {
        APP.unblockGeneration(type);
    }
};
/**
 * æ’ä»¶çš„ä¸»åˆå§‹åŒ–å‡½æ•°ã€‚
 * ä½¿ç”¨ jQuery(async () => { ... }) ç¡®ä¿åœ¨æ–‡æ¡£å¯¹è±¡æ¨¡å‹(DOM)å®Œå…¨åŠ è½½å’Œè§£æå®Œæ¯•åæ‰§è¡Œã€‚
 * è¿™æ˜¯Webå¼€å‘çš„æ ‡å‡†å®è·µï¼Œå¯ä»¥é˜²æ­¢å› å°è¯•æ“ä½œä¸å­˜åœ¨çš„å…ƒç´ è€Œå¯¼è‡´çš„é”™è¯¯ã€‚
 */
jQuery(async () => {
    try {
        const script = document.createElement('script');
        script.type = 'module';
        script.innerHTML = `
            import { GoogleGenerativeAI } from 'https://esm.run/@google/generative-ai';
            window.GoogleGenerativeAI = GoogleGenerativeAI;
        `;
        document.head.appendChild(script);
        console.log('[Hevno] Google Generative AI SDK script injected.');
    } catch (error) {
        console.error('[Hevno] Failed to inject Google AI SDK.', error);
        toastr.error("Failed to load Google AI library. Gemini features will not work.", "Dependency Error");
    }

    // ä»»åŠ¡1: æ³¨å…¥æ’ä»¶çš„è®¾ç½®UIç•Œé¢ã€‚
    try {
        // ä½¿ç”¨æˆ‘ä»¬å°è£…çš„ SYSTEM ç®¡ç†å™¨æ¥å¼‚æ­¥åŠ è½½HTMLæ¨¡æ¿ã€‚
        const settingsHtml = await SYSTEM.getTemplate('settings');

        // ä½¿ç”¨jQueryå°†åŠ è½½çš„HTMLå†…å®¹é™„åŠ åˆ°SillyTavernçš„æ‰©å±•è®¾ç½®é¢æ¿ä¸­ã€‚
        // '#extensions_settings' æ˜¯SillyTavernä¸­ç”¨äºæ”¾ç½®æ‰€æœ‰æ’ä»¶è®¾ç½®çš„å®¹å™¨IDã€‚
        $('#extensions_settings').append(settingsHtml);

        // åŠ è½½è®¾ç½®çš„åˆå§‹å€¼å¹¶ä¸ºUIå…ƒç´ ç»‘å®šäº‹ä»¶ç›‘å¬å™¨ã€‚
        loadSettings();

    } catch (error) {
        console.error("[Hevno] Failed to load settings UI.", error);
    }

    console.log("______________________ Hevno Plugin: Loaded Successfully ______________________");
});
```

### llm_callers/gemini_caller.js
```
// src/llm_callers/gemini_caller.js

import { apiKeyManager } from '../core/apiKeyManager.js';
import { llmLogger } from '../utils/llm_logger.js';

/**
 * ã€V4 - è§£è€¦ç‰ˆã€‘æ‰§è¡Œå¯¹Google Gemini APIçš„è°ƒç”¨ã€‚
 * è‡ªèº«ä¸åŒ…å«é‡è¯•é€»è¾‘ï¼Œå®Œå…¨ä¾èµ–ApiKeyManagerè¿›è¡Œå¯†é’¥è½®æ¢ã€‚
 * @param {string} prompt - å®Œæ•´çš„ã€æ¸²æŸ“åçš„promptã€‚
 * @param {object} llmConfig - æ¥è‡ªæ¨¡å—å®šä¹‰çš„LLMé…ç½®ã€‚
 * @returns {Promise<string>} LLMç”Ÿæˆçš„æ–‡æœ¬ã€‚
 */
export async function execute(prompt, llmConfig) {
    if (typeof window.GoogleGenerativeAI === 'undefined') {
        throw new Error("Google Generative AI SDK is not loaded.");
    }

    const { model, temperature = 0.7, topP = 1.0, maxOutputTokens = 2048 } = llmConfig;
    let lastError = null;
    let retryAttempt = 0;
    const sessionId = llmLogger.generateSessionId();
    
    const startTime = Date.now();
    console.log(`[LLM-Exec] ï¿½ Session ${sessionId} | Starting execution...`);
    
    // å¾ªç¯ï¼Œç›´åˆ°æˆåŠŸï¼Œæˆ–ApiKeyManagerå‘ŠçŸ¥æˆ‘ä»¬å·²æ— å¥åº·å¯†é’¥å¯ç”¨
    while (true) {
        retryAttempt++;
        const key = await apiKeyManager.getHealthyKey();

        if (!key) {
            const duration = Date.now() - startTime;
            console.error(`[LLM-Exec] âŒ Session ${sessionId} | No healthy keys available | ${duration}ms`);
            throw lastError || new Error("No healthy API keys available to fulfill the request.");
        }

        try {
            console.log(`[LLM-Exec] ğŸ”‘ Session ${sessionId} | Using key ...${key.slice(-4)} | Attempt ${retryAttempt}`);
            
            const genAI = new window.GoogleGenerativeAI(key);
            const generativeModel = genAI.getGenerativeModel({
                model: model,
                generationConfig: { temperature, topP, maxOutputTokens },
            });
            const contents = [{ role: "user", parts: [{ text: prompt }] }];

            const result = await generativeModel.generateContent({ contents });
            const response = await result.response;
            const text = response.text();
            const duration = Date.now() - startTime;
            
            // è§£æAPIå“åº”è¯¦æƒ…
            const responseData = {
                text: text,
                candidates: response.candidates || [],
                promptFeedback: response.promptFeedback || null,
                usageMetadata: response.usageMetadata || null,
                finishReason: response.candidates?.[0]?.finishReason || 'unknown',
                safetyRatings: response.candidates?.[0]?.safetyRatings || []
            };
            
            // æŠ€æœ¯æ‰§è¡Œå±‚çš„çŠ¶æ€æ—¥å¿—
            if (!text || text.trim().length === 0) {
                console.warn(`[LLM-Exec] âš ï¸  Session ${sessionId} | EMPTY RESPONSE | ${duration}ms`);
                console.warn(`[LLM-Exec] ğŸ” Session ${sessionId} | Candidates: ${responseData.candidates.length} | Finish: ${responseData.finishReason}`);
                
                // è¯¦ç»†çš„ç©ºå“åº”åˆ†æ
                if (responseData.promptFeedback) {
                    console.warn(`[LLM-Exec] ğŸ›¡ï¸  Session ${sessionId} | Prompt blocked:`, responseData.promptFeedback);
                }
                if (responseData.safetyRatings.length > 0) {
                    console.warn(`[LLM-Exec] ğŸ›¡ï¸  Session ${sessionId} | Safety ratings:`, responseData.safetyRatings);
                }
                
                // ä½¿ç”¨æ—¥å¿—å·¥å…·è¿›è¡Œæ·±åº¦åˆ†æ
                llmLogger.logEmptyResponse(sessionId, prompt, llmConfig, responseData, {
                    apiKey: key,
                    retryAttempt,
                    duration
                });
            } else {
                console.log(`[LLM-Exec] âœ… Session ${sessionId} | Success | ${text.length} chars | ${duration}ms`);
                
                // è®°å½•Tokenä½¿ç”¨æƒ…å†µ
                if (responseData.usageMetadata) {
                    const usage = responseData.usageMetadata;
                    console.log(`[LLM-Exec] ğŸ“Š Session ${sessionId} | Tokens: ${usage.promptTokenCount}â†’${usage.candidatesTokenCount} (${usage.totalTokenCount} total)`);
                }
            }

            // æˆåŠŸï¼é‡Šæ”¾keyå¹¶è¿”å›ç»“æœ
            apiKeyManager.releaseKey(key);
            return text;

        } catch (error) {
            lastError = error;
            const duration = Date.now() - startTime;
            
            console.error(`[LLM-Exec] âŒ Session ${sessionId} | Key ...${key.slice(-4)} failed | ${duration}ms`);
            console.error(`[LLM-Exec] ğŸ” Session ${sessionId} | Error: ${error.name} - ${error.message}`);
            
            // ä½¿ç”¨åˆ†æå·¥å…·è¿›è¡Œé”™è¯¯åˆ†æ
            if (retryAttempt === 1) { // åªåœ¨ç¬¬ä¸€æ¬¡å¤±è´¥æ—¶è¯¦ç»†åˆ†æ
                llmLogger.analyzeError(error, { apiKey: key, sessionId });
            }
            
            await apiKeyManager.recordFailure(key, error);
        }
    }
}
```

### core/llm_dispatcher.js
```
// src/core/llm_dispatcher.js

import * as geminiCaller from '../llm_callers/gemini_caller.js';
// æœªæ¥å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šcaller:
// import * as openaiCaller from '../llm_callers/openai_caller.js';

const providers = {
    'gemini': geminiCaller,
    // 'openai': openaiCaller,
};

/**
 * æ ¹æ®llmConfigä¸­çš„providerï¼Œå°†è¯·æ±‚åˆ†æ´¾ç»™æ­£ç¡®çš„LLMè°ƒç”¨è€…ã€‚
 * @param {string} prompt - æ¸²æŸ“åçš„promptã€‚
 * @param {object} llmConfig - æ¨¡å—çš„LLMé…ç½®ã€‚
 * @returns {Promise<string>} æ¥è‡ªLLMçš„å“åº”ã€‚
 */
export async function dispatch(prompt, llmConfig) {
    const providerName = llmConfig.provider;
    if (!providerName) {
        throw new Error("Module is missing 'provider' field in its 'llm' configuration.");
    }

    const caller = providers[providerName.toLowerCase()];
    if (!caller) {
        throw new Error(`Unsupported LLM provider: "${providerName}". No caller found.`);
    }

    // ç®€æ´çš„è°ƒåº¦æ—¥å¿—
    console.log(`[LLM-Dispatch] ğŸš€ Routing to ${providerName}/${llmConfig.model || 'default'}`);

    try {
        const result = await caller.execute(prompt, llmConfig);
        console.log(`[LLM-Dispatch] âœ… ${providerName} completed successfully`);
        return result;
    } catch (error) {
        console.error(`[LLM-Dispatch] âŒ ${providerName} failed: ${error.message}`);
        throw error;
    }
}
```

### core/manager.js
```
// src/core/manager.js

/**
 * @file manager.js
 * @description æ’ä»¶çš„æ ¸å¿ƒç®¡ç†å™¨å’ŒAPIæŠ½è±¡å±‚ã€‚
 */

// I. å¯¼å…¥SillyTavernçš„æ ¸å¿ƒåŠŸèƒ½
import {
    eventSource,
    event_types,
    saveSettingsDebounced,
    saveReply,
    saveChatConditional,
    activateSendButtons,
    addOneMessage,
    deleteLastMessage,
    generateRaw,
    reloadCurrentChat,
    sendSystemMessage,
    substituteParams,
} from '/script.js';
import { getTokenCountAsync } from '/scripts/tokenizers.js';
import { getContext, extension_settings, renderExtensionTemplateAsync } from '/scripts/extensions.js';
import { Popup, POPUP_TYPE, callGenericPopup } from '/scripts/popup.js';

// ã€ä¿®æ”¹ã€‘å¯¼å…¥æ­£ç¡®çš„ã€é«˜å±‚çš„APIå’Œå¯å†™å˜é‡
import {
    getWorldInfoPrompt,
    selected_world_info,
    loadWorldInfo,
    world_names,
    world_info, // æ·»åŠ è¿™ä¸ªå¯¼å…¥æ¥è®¿é—®ä¸–ç•Œä¹¦æ•°æ®
} from '/scripts/world-info.js';

import { defaultSettings } from '../data/pluginSetting.js';

// II. å®šä¹‰å’Œå¯¼å‡ºç®¡ç†å™¨

/**
 * @namespace APP
 * @description åº”ç”¨ç®¡ç†å™¨ (APP)
 */
export const APP = {
    getContext,
    eventSource,
    event_types,
    saveReply,
    unblockGeneration: activateSendButtons,
    generateRaw,
    addOneMessage,
    sendSystemMessage,
    deleteLastMessage,
    reloadCurrentChat,
    saveChatConditional,
    renderExtensionTemplateAsync,
    substituteParams,
    getTokenCountAsync,
};

/**
 * @namespace USER
 * @description ç”¨æˆ·æ•°æ®ç®¡ç†å™¨ (USER)
 */
export const USER = {
    settings: new Proxy({}, {
        get(_, property) {
            const settings = extension_settings.Hevno_settings;
            if (settings && property in settings) {
                return settings[property];
            }
            return defaultSettings[property];
        },
        set(_, property, value) {
            if (!extension_settings.Hevno_settings) {
                extension_settings.Hevno_settings = {};
            }
            extension_settings.Hevno_settings[property] = value;
            saveSettingsDebounced();
            return true;
        },
    }),
    saveSettings: saveSettingsDebounced,
};

/**
 * @namespace EDITOR
 * @description ç¼–è¾‘å™¨/UIç®¡ç†å™¨ (EDITOR)
 */
export const EDITOR = {
    Popup,
    POPUP_TYPE,
    callGenericPopup,
};

/**
 * @namespace SYSTEM
 * @description ç³»ç»Ÿå·¥å…·ç®¡ç†å™¨ (SYSTEM)
 */
export const SYSTEM = {
    getTemplate: (name) => {
        return APP.renderExtensionTemplateAsync('third-party/Hevno/assets/templates', name);
    },

    /**
     * ã€æœ€ç»ˆç‰ˆã€‘å°è£… SillyTavern çš„é¡¶å±‚ World Info è·å–å‡½æ•°ã€‚
     * @param {Array<string>} chat - èŠå¤©æ¶ˆæ¯æ–‡æœ¬æ•°ç»„
     * @param {number} maxContext - æœ€å¤§ä¸Šä¸‹æ–‡å¤§å°
     * @param {boolean} isDryRun - æ˜¯å¦ä¸ºæ¼”ç»ƒæ¨¡å¼
     * @param {object} globalScanData - è§’è‰²ã€åœºæ™¯ç­‰é™„åŠ æ‰«ææ•°æ®
     * @returns {Promise<object>} è¿”å›ä¸€ä¸ªåŒ…å« .worldInfoString çš„å¯¹è±¡
     */
    getWorldInfoPrompt: getWorldInfoPrompt,

    /**
     * è·å–å½“å‰å…¨å±€é€‰æ‹©çš„ä¸–ç•Œä¹¦åˆ—è¡¨ã€‚
     * @returns {Array<string>}
     */
    getSelectedWorldInfo: () => [...selected_world_info],

    /**
     * ä¸´æ—¶è®¾ç½®SillyTavernå…¨å±€é€‰æ‹©çš„ä¸–ç•Œä¹¦åˆ—è¡¨ã€‚
     * @param {Array<string>} worlds - ä¸–ç•Œä¹¦æ–‡ä»¶ååˆ—è¡¨ã€‚
     */
    setSelectedWorldInfo: (worlds) => {
        selected_world_info.length = 0;
        selected_world_info.push(...worlds);
    },

    /**
     * ã€æ–°å¢ã€‘ç›´æ¥æš´éœ²SillyTavernçš„WIæ–‡ä»¶åŠ è½½å‡½æ•°ã€‚
     * @param {string} worldName - è¦åŠ è½½çš„ä¸–ç•Œä¹¦æ–‡ä»¶åã€‚
     * @returns {Promise<object|null>} åŠ è½½çš„æ•°æ®æˆ–nullã€‚
     */
    loadWorldInfo: loadWorldInfo,

    /**
     * ã€æ–°å¢ã€‘æ¸…ç†ä¸–ç•Œä¹¦ç¼“å­˜å’ŒçŠ¶æ€
     */
    clearWorldInfoCache: () => {
        try {
            // æ¸…ç†world_infoä¸­çš„æ‰€æœ‰æ¡ç›®
            if (world_info && typeof world_info === 'object') {
                Object.keys(world_info).forEach(key => {
                    delete world_info[key];
                });
            }
            console.log('[SYSTEM] World info cache cleared');
        } catch (error) {
            console.warn('[SYSTEM] Failed to clear world info cache:', error);
        }
    },

    /**
     * ã€æ–°å¢ã€‘å¸è½½æ‰€æœ‰å·²åŠ è½½çš„ä¸–ç•Œä¹¦ï¼ˆä½†ä¿ç•™é€‰æ‹©åˆ—è¡¨ï¼‰
     */
    unloadAllWorldInfo: async () => {
        try {
            // ã€ä¿®å¤ã€‘åªæ¸…ç†ä¸–ç•Œä¹¦æ•°æ®ç¼“å­˜ï¼Œä¸æ¸…ç†é€‰æ‹©åˆ—è¡¨
            // è¿™æ ·loadWorldInfoå¯ä»¥é‡æ–°åŠ è½½ï¼Œä½†selected_world_infoä¿æŒæ­£ç¡®çŠ¶æ€
            if (world_info && typeof world_info === 'object') {
                Object.keys(world_info).forEach(key => {
                    delete world_info[key];
                });
            }
            
            console.log('[SYSTEM] World info data cleared (keeping selection)');
        } catch (error) {
            console.warn('[SYSTEM] Failed to unload world info:', error);
        }
    },


    /**
     * ã€æ–°å¢ã€‘è·å–æ‰€æœ‰å·²çŸ¥çš„ä¸–ç•Œä¹¦æ–‡ä»¶åã€‚
     * @returns {Array<string>}
     */
    getWorldNames: () => [...world_names],


    /**
     * ã€æ–°å¢ã€‘ä¸´æ—¶è®¾ç½®æ‰€æœ‰å·²çŸ¥çš„ä¸–ç•Œä¹¦æ–‡ä»¶åã€‚
     * @param {Array<string>} newWorldNames - æ–°çš„ä¸–ç•Œä¹¦æ–‡ä»¶ååˆ—è¡¨ã€‚
     */
    setWorldNames: (newWorldNames) => {
        world_names.length = 0; // Clear the array
        Array.prototype.push.apply(world_names, newWorldNames); // Mutate it
    },

    /**
     * è·å–è§’è‰²æ•°æ®
     * @returns {Array}
     */
    getCharacters: () => getContext()?.characters || [],

    /**
     * è·å–å½“å‰è§’è‰²ID
     * @returns {number}
     */
    getCurrentCharacterId: () => getContext()?.characterId || -1,

    /**
     * è·å–èŠå¤©å…ƒæ•°æ®
     * @returns {object}
     */
    getChatMetadata: () => getContext()?.chat_metadata || {},

    /**
     * è®¾ç½®èŠå¤©å…ƒæ•°æ®
     * @param {string} key
     * @param {any} value
     */
    setChatMetadata: (key, value) => {
        const context = getContext();
        if (context?.chat_metadata) {
            context.chat_metadata[key] = value;
        }
    },

    /**
     * è·å–power_userå¯¹è±¡
     * @returns {object}
     */
    getPowerUser: () => getContext()?.power_user || {},

    /**
     * METADATA_KEYå¸¸é‡
     */
    METADATA_KEY: 'world_info',

    /**
     * è·å–ä¸–ç•Œä¹¦æ•°æ®å¯¹è±¡
     * @returns {object}
     */
    getWorldInfoData: () => world_info,
};
```

### core/function_registry.js
```
// src/core/function_registry.js

import { USER } from './manager.js';

/**
 * @file function_registry.js
 * @description å­˜æ”¾æ‰€æœ‰å¯è¢«FunctionNodeè°ƒç”¨çš„è‡ªå®šä¹‰JSå‡½æ•°ã€‚
 * 
 * ã€è®¾è®¡å“²å­¦ V2 - é€šç”¨æ€§ä¸å¯ç»„åˆæ€§ã€‘
 * 1.  **å•ä¸€èŒè´£**: æ¯ä¸ªå‡½æ•°åªåšä¸€ä»¶å°äº‹ï¼Œå¹¶æŠŠå®ƒåšå¥½ã€‚ä¾‹å¦‚ï¼Œä¸å°†â€œæ£€æŸ¥æ–‡æœ¬â€å’Œâ€œå†³å®šæ˜¯å¦æˆ˜æ–—â€æ··ä¸ºä¸€è°ˆã€‚
 * 2.  **é€šç”¨æ€§**: å‡½æ•°ååº”æè¿°å…¶é€šç”¨è¡Œä¸ºï¼Œè€Œä¸æ˜¯æŸä¸ªç‰¹å®šçš„ä¸šåŠ¡åœºæ™¯ã€‚ä¾‹å¦‚ï¼Œ`textContains` è€Œä¸æ˜¯ `isCombatRequired`ã€‚
 * 3.  **å‚æ•°åŒ–**: å°†ç¡¬ç¼–ç çš„å€¼ï¼ˆå¦‚ "yes", "<thinking>") æå–ä¸ºå‚æ•°ï¼Œè®©ç”¨æˆ·åœ¨ Pipeline å®šä¹‰ä¸­æŒ‡å®šå®ƒä»¬ã€‚
 * 4.  **ä¸Šä¸‹æ–‡ä½œä¸ºè¾“å…¥**: æ¯ä¸ªå‡½æ•°éƒ½æ¥æ”¶å®Œæ•´çš„ç¼–æ’å™¨ä¸Šä¸‹æ–‡(context)å’ŒèŠ‚ç‚¹å‚æ•°(params)ã€‚
 * 5.  **å¯é¢„æµ‹çš„è¾“å‡º**: å‡½æ•°çš„è¿”å›å€¼åº”è¯¥æ˜¯ç®€å•ã€å¯é¢„æµ‹çš„æ•°æ®ç±»å‹ï¼ˆå­—ç¬¦ä¸²ã€æ•°ç»„ã€å¸ƒå°”å€¼ï¼‰ï¼Œä»¥ä¾¿äºä¸‹æ¸¸èŠ‚ç‚¹æ¶ˆè´¹ã€‚
 */
export const functionRegistry = {
    // =================================================================
    // æ–‡æœ¬å¤„ç†å·¥å…· (Text Processing Utilities)
    // =================================================================

    /**
     * ã€æ–°ã€‘æ£€æŸ¥è¾“å…¥æ–‡æœ¬æ˜¯å¦åŒ…å«æŒ‡å®šçš„å…³é”®å­—ã€‚
     * è¿™æ˜¯ isCombatRequired çš„é€šç”¨æ›¿ä»£å“ã€‚
     * @param {object} context 
     * @param {object} params - { sourceNode: string, keyword: string, caseSensitive: boolean (default: false) }
     * @returns {boolean} å¦‚æœæ‰¾åˆ°å…³é”®å­—ï¼Œåˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚
     */
    textContains: (context, params) => {
        const { sourceNode, keyword, caseSensitive = false } = params;
        if (!keyword) throw new Error("[textContains] 'keyword' parameter is required.");
        
        const rawOutput = context.outputs[sourceNode];
        if (typeof rawOutput !== 'string') return false;

        if (caseSensitive) {
            return rawOutput.includes(keyword);
        } else {
            return rawOutput.toLowerCase().includes(keyword.toLowerCase());
        }
    },

    /**
     * ã€æ–°ã€‘ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ›¿æ¢æ–‡æœ¬å†…å®¹ã€‚
     * è¿™æ˜¯ stripLlmThinking çš„é€šç”¨æ›¿ä»£å“ã€‚
     * @param {object} context 
     * @param {object} params - { sourceNode: string, pattern: string, flags: string (default: 'g'), replacement: string (default: '') }
     * @returns {string} å¤„ç†åçš„å­—ç¬¦ä¸²ã€‚
     */
    regexReplace: (context, params) => {
        const { sourceNode, pattern, flags = 'g', replacement = '' } = params;
        if (!pattern) throw new Error("[regexReplace] 'pattern' parameter is required.");

        const rawOutput = context.outputs[sourceNode];
        if (typeof rawOutput !== 'string') return '';

        try {
            const regex = new RegExp(pattern, flags);
            return rawOutput.replace(regex, replacement);
        } catch (e) {
            throw new Error(`[regexReplace] Invalid regex pattern: ${e.message}`);
        }
    },

    /**
     * ã€æ–°ã€‘ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ä»æ–‡æœ¬ä¸­æå–æ‰€æœ‰åŒ¹é…é¡¹çš„ç‰¹å®šæ•è·ç»„ã€‚
     * è¿™æ˜¯ä¸€ä¸ªæ›´åº•å±‚çš„å·¥å…·ï¼Œå¯ç”¨äºå®ç°åƒ parseCharacterList è¿™æ ·çš„åŠŸèƒ½ã€‚
     * @param {object} context 
     * @param {object} params - { sourceNode: string, pattern: string, flags: string (default: 'g'), groupIndex: number (default: 1) }
     * @returns {string[]} åŒ…å«æ‰€æœ‰åŒ¹é…çš„æ•è·ç»„æ–‡æœ¬çš„æ•°ç»„ã€‚
     */
    extractWithRegex: (context, params) => {
        const { sourceNode, pattern, flags = 'g', groupIndex = 1 } = params;
        if (!pattern) throw new Error("[extractWithRegex] 'pattern' parameter is required.");

        const rawOutput = context.outputs[sourceNode];
        if (typeof rawOutput !== 'string') return [];

        try {
            const regex = new RegExp(pattern, flags);
            const matches = [...rawOutput.matchAll(regex)];
            return matches.map(match => match[groupIndex] || '').filter(Boolean);
        } catch (e) {
            throw new Error(`[extractWithRegex] Invalid regex pattern: ${e.message}`);
        }
    },

    // =================================================================
    // ç»“æ„åŒ–æ•°æ®å¤„ç† (Structured Data Processing)
    // =================================================================

    /**
     * ã€ä¿ç•™å¹¶æ”¹è¿›ã€‘è¿™æ˜¯ä¸€ä¸ªé«˜çº§ä¾¿åˆ©å‡½æ•°ï¼Œç”¨äºä»ç‰¹å®šæ ¼å¼çš„æ–‡æœ¬ä¸­è§£æè§’è‰²åˆ—è¡¨ã€‚
     * å®ƒå†…éƒ¨ä½¿ç”¨äº†æ›´é€šç”¨çš„é€»è¾‘ï¼Œä½†ä¸ºå¸¸è§ä»»åŠ¡æä¾›äº†ä¾¿åˆ©ã€‚
     * @param {object} context
     * @param {object} params - { sourceNode: string }
     * @returns {string[]} è§£æå‡ºçš„è§’è‰²åç§°æ•°ç»„ã€‚
     */
    parseCharacterList: (context, params) => {
        const rawOutput = context.outputs[params.sourceNode];
        if (!rawOutput) return [];
        
        const lowerCaseOutput = rawOutput.toLowerCase();
        
        // æ£€æŸ¥æ˜¯å¦æ˜ç¡®æŒ‡å‡ºæ²¡æœ‰è§’è‰²
        if (lowerCaseOutput.includes('characters: none') || lowerCaseOutput.includes('characters:none')) {
            return [];
        }

        const matches = rawOutput.match(/Characters:(.*)/i);
        if (matches && matches[1]) {
            const characterString = matches[1].trim();
            if (characterString.toLowerCase() === 'none' || characterString === '') {
                return [];
            }
            return characterString.split(',').map(name => name.trim()).filter(Boolean);
        }
        return [];
    },

    /**
     * ã€æ–°ã€‘èšåˆæ¥è‡ª Map èŠ‚ç‚¹çš„åŠ¨æ€è¾“å‡ºã€‚
     * è¿™æ˜¯ aggregateStoryParts çš„é€šç”¨ã€å¯é…ç½®çš„æ›¿ä»£å“ã€‚
     * @param {object} context
     * @param {object} params - { 
     *   sourceNodeIds: string[], 
     *   itemTemplate: string (e.g., "Action for {{item}}: {{output}}"), 
     *   separator: string (default: '\n\n') 
     * }
     * @returns {string} æ‹¼æ¥åçš„å­—ç¬¦ä¸²ã€‚
     */
    joinFromDynamicNodes: (context, params) => {
        const { sourceNodeIds, itemTemplate, separator = '\n\n' } = params;
        if (!sourceNodeIds || !Array.isArray(sourceNodeIds)) return "";
        if (!itemTemplate) throw new Error("[joinFromDynamicNodes] 'itemTemplate' parameter is required.");
        
        const parts = sourceNodeIds.map(nodeId => {
            const output = context.outputs[nodeId] || '';
            const dynamicNodeDef = context.nodes[nodeId];
            const item = dynamicNodeDef?.injectedParams?.item || 'Unknown';
            
            return itemTemplate
                .replace(/{{output}}/g, output)
                .replace(/{{item}}/g, item);
        });
        
        return parts.join(separator);
    },

    // =================================================================
    // éªŒè¯ä¸é€»è¾‘ (Validation & Logic)
    // =================================================================

    /**
     * ã€æ–°ã€‘éªŒè¯è¾“å…¥æ–‡æœ¬çš„æœ€å°é•¿åº¦ã€‚
     * å¯ç”¨äºæ„å»ºé‡è¯•å¾ªç¯ã€‚
     * @param {object} context
     * @param {object} params - { sourceNode: string, minLength: number }
     * @returns {boolean} å¦‚æœæ–‡æœ¬é•¿åº¦å¤§äºç­‰äº minLengthï¼Œåˆ™è¿”å› trueã€‚
     */
    validateMinLength: (context, params) => {
        const { sourceNode, minLength = 1 } = params;
        const rawOutput = context.outputs[sourceNode];
        if (typeof rawOutput !== 'string') return false;

        return rawOutput.trim().length >= minLength;
    }
};

/**
 * å®‰å…¨åœ°æ‰§è¡Œæ³¨å†Œè¡¨ä¸­çš„å‡½æ•°ã€‚
 * @param {string} functionName - è¦æ‰§è¡Œçš„å‡½æ•°åã€‚
 * @param {object} context - ç¼–æ’å™¨ä¸Šä¸‹æ–‡ã€‚
 * @param {object} params - èŠ‚ç‚¹å®šä¹‰ä¸­çš„å‚æ•°ã€‚
 * @returns {any} å‡½æ•°çš„è¿”å›å€¼ã€‚
 */
export function executeFunction(functionName, context, params) {
    if (typeof functionRegistry[functionName] !== 'function') {
        throw new Error(`Function "${functionName}" is not defined in the function registry.`);
    }
    return functionRegistry[functionName](context, params);
}
```

### core/apiKeyManager.js
```
// src/core/apiKeyManager.js

import { USER } from './manager.js';
import { renderSettings } from '../scripts/settings/userExtensionSetting.js';

// --- Key Status Enums ---
const KEY_STATUS = {
    HEALTHY: 'healthy',
    BANNED: 'banned',
    SUSPENDED: 'suspended'
};

const QUOTA_ERROR_LIMIT_PER_DAY = 5;

// --- é”™è¯¯åˆ†ç±»å‡½æ•° ---
function getErrorType(error) {
    const message = error.message.toLowerCase();
    const status = error.message.match(/\[(\d{3})\]/)?.[1] || '';

    if (message.includes('api key not valid') || 
        message.includes('permission denied') || 
        message.includes('consumer suspended') ||
        message.includes('expired') ||
        (status === '403') ||
        (status === '400') // å°†400ä½œä¸ºAPI Keyé”™è¯¯çš„å¼ºä¿¡å·ï¼Œå› ä¸ºå®ƒé€šå¸¸ä¸è¯·æ±‚æ ¼å¼æˆ–è®¤è¯æœ‰å…³
    ) {
        return 'ApiKeyError';
    }
    if (status === '429' || message.includes('quota exceeded') || message.includes('rate limit exceeded')) {
        return 'QuotaError';
    }
    // [!code focus:start]
    // --- æ–°å¢ï¼šè¯†åˆ«è‡ªå®šä¹‰çš„ç©ºå“åº”é”™è¯¯ ---
    if (message.includes('emptyresponseerror') || status.startsWith('5') || message.includes('socket hang up') || message.includes('fetch failed')|| message.includes('prohibited')) {
        return 'NetworkError'; // å°†ç©ºå“åº”å½’ç±»ä¸ºç½‘ç»œ/ç¬æ—¶é”™è¯¯
    }
    // [!code focus:end]
    return 'UnknownError';
}

// ... ApiKeyManager ç±»çš„å…¶ä½™éƒ¨åˆ†ä¿æŒä¸å˜ ...
class ApiKeyManager {
    constructor() {
        this.keyPool = new Map(); // key -> { status: string, stats: object }
        this.busyKeys = new Set();
        this.waitQueue = [];
    }

    /**
     * ä»ç”¨æˆ·è®¾ç½®åŠ è½½æˆ–åˆ·æ–°APIå¯†é’¥æ± ã€‚
     */
    loadKeys() {
        const userKeys = USER.settings.geminiApiKeys || [];
        const today = new Date().toISOString().slice(0, 10);

        // æ¸…ç†æ—§çš„keyï¼Œä¿ç•™å·²æœ‰çš„å¥åº·æ•°æ®
        const newKeySet = new Set(userKeys);
        for (const key of this.keyPool.keys()) {
            if (!newKeySet.has(key)) {
                this.keyPool.delete(key);
            }
        }
        
        // æ·»åŠ æ–°keyæˆ–æ›´æ–°ç°æœ‰keyçš„çŠ¶æ€
        userKeys.forEach(key => {
            if (key && key.trim() !== '') {
                if (!this.keyPool.has(key)) {
                    this.keyPool.set(key, {
                        status: KEY_STATUS.HEALTHY,
                        stats: {
                            lastErrorDate: '',
                            quotaErrorCount: 0,
                            networkErrorCount: 0,
                            suspensionEndTime: 0
                        }
                    });
                } else {
                    // å¦‚æœæ˜¯æ–°çš„ä¸€å¤©ï¼Œé‡ç½®æ¯æ—¥é…é¢è®¡æ•°
                    const entry = this.keyPool.get(key);
                    if (entry.stats.lastErrorDate !== today) {
                        entry.stats.quotaErrorCount = 0;
                    }
                    // å¦‚æœåœç”¨æ—¶é—´å·²è¿‡ï¼Œæ¢å¤å¥åº·çŠ¶æ€
                    if (entry.status === KEY_STATUS.SUSPENDED && Date.now() > entry.stats.suspensionEndTime) {
                        entry.status = KEY_STATUS.HEALTHY;
                        entry.stats.suspensionEndTime = 0;
                        console.log(`[ApiKeyManager] Key ...${key.slice(-4)} has been restored from suspension.`);
                    }
                }
            }
        });

        console.log(`[ApiKeyManager] Loaded and synchronized ${this.keyPool.size} keys.`);
        this._processWaitQueue();
    }

    /**
     * è·å–ä¸€ä¸ªå¥åº·çš„ã€ç©ºé—²çš„APIå¯†é’¥ã€‚
     * @returns {Promise<string|null>} ä¸€ä¸ªè§£æä¸ºå¯ç”¨å¯†é’¥æˆ–nullçš„Promiseã€‚
     */
    getHealthyKey() {
        // æ¯æ¬¡è·å–æ—¶éƒ½åˆ·æ–°çŠ¶æ€ï¼Œç¡®ä¿åŠæ—¶æ¢å¤è¢«æš‚åœçš„key
        this.loadKeys(); 

        const healthyAndFreeKeys = Array.from(this.keyPool.entries())
            .filter(([key, data]) => 
                data.status === KEY_STATUS.HEALTHY && !this.busyKeys.has(key)
            );

        if (healthyAndFreeKeys.length > 0) {
            const [keyToUse] = healthyAndFreeKeys[0]; 
            this.busyKeys.add(keyToUse);
            console.log(`[ApiKeyManager] Acquired healthy key ...${keyToUse.slice(-4)}`);
            return Promise.resolve(keyToUse);
        }
        
        const healthyButBusy = Array.from(this.keyPool.entries())
            .some(([key, data]) => data.status === KEY_STATUS.HEALTHY && this.busyKeys.has(key));
            
        if (healthyButBusy) {
             console.log(`[ApiKeyManager] All healthy keys are busy. Request is now waiting.`);
             return new Promise(resolve => this.waitQueue.push(resolve));
        }

        return Promise.resolve(null);
    }

    /**
     * æŠ¥å‘Šä¸€æ¬¡å¤±è´¥ï¼Œç®¡ç†å™¨å°†æ®æ­¤æ›´æ–°å¯†é’¥çŠ¶æ€ã€‚
     * @param {string} key - å¤±è´¥çš„å¯†é’¥ã€‚
     * @param {Error} error - æ•è·åˆ°çš„é”™è¯¯å¯¹è±¡ã€‚
     */
    async recordFailure(key, error) {
        if (!this.keyPool.has(key)) return;

        const entry = this.keyPool.get(key);
        const errorType = getErrorType(error);
        const today = new Date().toISOString().slice(0, 10);
        entry.stats.lastErrorDate = today;

        console.warn(`[ApiKeyManager] Failure recorded for key ...${key.slice(-4)}. Type: ${errorType}. Error: ${error.message}`);

        switch (errorType) {
            case 'ApiKeyError':
                entry.status = KEY_STATUS.BANNED;
                console.error(`[ApiKeyManager] Key ...${key.slice(-4)} has been permanently banned.`);
                toastr.error(`An API key (...${key.slice(-4)}) was found to be invalid/banned and has been permanently disabled.`, "API Key Banned");
                
                // [!code focus:start]
                // ã€å…³é”®ä¿®æ­£ã€‘æˆ‘ä»¬åº”è¯¥ç›´æ¥åœ¨è¿™é‡Œä¿®æ”¹ç”¨æˆ·è®¾ç½®ï¼Œè€Œä¸æ˜¯ä¾èµ–ä¸‹æ¬¡loadKeys
                const currentKeys = USER.settings.geminiApiKeys || [];
                // è¿‡æ»¤æ‰å½“å‰åæ‰çš„key
                const newKeys = currentKeys.filter(k => k !== key);
                // ç¡®ä¿ USER.settings.geminiApiKeys è¢«æ­£ç¡®èµ‹å€¼ä»¥è§¦å‘ä»£ç†çš„set
                if (newKeys.length !== currentKeys.length) {
                    USER.settings.geminiApiKeys = newKeys;
                }

            case 'QuotaError':
                entry.stats.quotaErrorCount++;
                if (entry.stats.quotaErrorCount >= QUOTA_ERROR_LIMIT_PER_DAY) {
                    entry.status = KEY_STATUS.SUSPENDED;
                    const tomorrow = new Date();
                    tomorrow.setHours(24, 0, 0, 0); 
                    entry.stats.suspensionEndTime = tomorrow.getTime();
                    console.error(`[ApiKeyManager] Key ...${key.slice(-4)} has reached its daily quota limit and is suspended until tomorrow.`);
                    toastr.warning(`An API key (...${key.slice(-4)}) seems to have hit its daily limit. It will be temporarily disabled.`, "Key Suspended");
                }
                break;
                
            case 'NetworkError':
                entry.stats.networkErrorCount++;
                break;
        }
        
        this.releaseKey(key);
    }
    
    releaseKey(key) {
        if (key && this.busyKeys.has(key)) {
            this.busyKeys.delete(key);
            console.log(`[ApiKeyManager] Released key ...${key.slice(-4)}.`);
            this._processWaitQueue();
        }
    }

    _processWaitQueue() {
        if (this.waitQueue.length > 0) {
            const healthyAndFreeKeys = Array.from(this.keyPool.entries())
                .filter(([key, data]) => 
                    data.status === KEY_STATUS.HEALTHY && !this.busyKeys.has(key)
                );
            if (healthyAndFreeKeys.length > 0) {
                const [keyToUse] = healthyAndFreeKeys[0];
                const nextInQueue = this.waitQueue.shift();
                this.busyKeys.add(keyToUse);
                console.log(`[ApiKeyManager] Re-assigned key ...${keyToUse.slice(-4)} to waiting request.`);
                nextInQueue(keyToUse);
            }
        }
    }
}

export const apiKeyManager = new ApiKeyManager();
```

### core/orchestrator.js
```
// src/core/orchestrator.js

import { dispatch as dispatchLLM } from './llm_dispatcher.js';
import { executeFunction } from './function_registry.js';
import { APP, SYSTEM } from './manager.js';

/**
 * @class GenerationOrchestrator
 * @description æ¨¡å—åŒ–ç”Ÿæˆæµç¨‹çš„ç¼–æ’ä¸æ‰§è¡Œå¼•æ“ï¼ˆV2 - æ”¯æŒåŠ¨æ€å›¾ï¼‰ã€‚
 */
export class GenerationOrchestrator {
    // ... constructor å’Œå…¶ä»–è¾…åŠ©å‡½æ•° (_formatChatHistory, _resolvePath, etc.) ä¿æŒä¸å˜ ...
    constructor(pipelineDefinition, initialSillyTavernContext) {
        this.initialPipeline = pipelineDefinition;
        this.rawContext = initialSillyTavernContext;

        // è¿è¡Œæ—¶çš„çŠ¶æ€
        this.nodes = {}; // å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹å®šä¹‰ï¼ŒåŒ…æ‹¬åŠ¨æ€ç”Ÿæˆçš„
        this.nodeStates = {}; // 'pending', 'running', 'completed', 'failed', 'skipped'
        this.dependencies = new Map(); // node_id -> Set<dependency_id>
        this.dependents = new Map(); // node_id -> Set<dependent_id>

        // ã€æ–°å¢ã€‘ä¸–ç•Œä¹¦è®¿é—®äº’æ–¥é”
        this.worldInfoMutex = Promise.resolve();

        this.context = {
            sillyTavern: {
                character: this.rawContext.characters[this.rawContext.characterId],
                userInput: this.rawContext.chat.slice(-1)[0]?.mes || '',
                userName: this.rawContext.name1,
                chat: this.rawContext.chat,
            },
            outputs: {}, // æ‰€æœ‰èŠ‚ç‚¹çš„è¾“å‡ºéƒ½å­˜åœ¨è¿™é‡Œ
            nodes: this.nodes, // è®©FunctionNodeå¯ä»¥è®¿é—®èŠ‚ç‚¹å®šä¹‰
            module: {}, // æ—§çš„æ¨¡å—ä¸Šä¸‹æ–‡ï¼Œä¿æŒå…¼å®¹æ€§
        };

        this.finalOutputNodeId = 'final_formatter'; // å¯ä»¥ä»ç®¡çº¿å…ƒæ•°æ®ä¸­è¯»å–
    }

    _formatChatHistory(chatArray) {
        if (!Array.isArray(chatArray)) return '';
        return chatArray.map(message => {
            const prefix = message.is_user ? (this.context.sillyTavern.userName || 'User') : (this.context.sillyTavern.character?.name || 'Assistant');
            return `${prefix}: ${message.mes}`;
        }).join('\n');
    }

    _resolvePath(path, contextObject) {
        // å…è®¸æ³¨å…¥åŠ¨æ€å‚æ•°ï¼Œä¾‹å¦‚æ¥è‡ªMapNode
        if (path.startsWith('item')) {
            const dynamicValue = path.split('.').reduce((acc, part) => (acc ? acc[part] : undefined), contextObject);
            if (dynamicValue !== undefined) return dynamicValue;
        }

        let current = contextObject;
        const parts = path.split('.');
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (current && typeof current === 'object' && part in current) {
                current = current[part];
            } else {
                // [!code focus:start]
                // ã€å·²ä¿®æ­£ã€‘åªåœ¨è·¯å¾„ä¸æ˜¯ä¸€ä¸ªå¯é€‰çš„ 'outputs' æ—¶æ‰å‘å‡ºè­¦å‘Šã€‚
                // è¿™æ˜¯ä¸ºäº†é¿å…åœ¨å¤„ç†ç”±è·¯ç”±å™¨è·³è¿‡çš„èŠ‚ç‚¹çš„è¾“å‡ºæ—¶äº§ç”Ÿä¸å¿…è¦çš„æ§åˆ¶å°å™ªéŸ³ã€‚
                if (!path.startsWith('outputs.')) {
                    console.warn(`[Orchestrator] Path resolution failed. Key "${part}" not found in context for path "${path}".`);
                }
                // [!code focus:end]
                return undefined;
            }
        }
        return current;
    }



    async _calculateModuleWorldInfo(module) {
        // æ­¥éª¤ 1: å¦‚æœèŠ‚ç‚¹æ²¡æœ‰é…ç½®World Infoï¼Œç›´æ¥è¿”å›ä¸€ä¸ªè§£æä¸ºç©ºå­—ç¬¦ä¸²çš„Promiseã€‚
        if (!module.worldInfo || !Array.isArray(module.worldInfo) || module.worldInfo.length === 0) {
            return Promise.resolve('');
        }

        // æ­¥éª¤ 2: æ£€æŸ¥å¿…è¦çš„SillyTavernå‡½æ•°æ˜¯å¦å­˜åœ¨ã€‚
        if (typeof SYSTEM.getWorldInfoPrompt !== 'function' || typeof SYSTEM.loadWorldInfo !== 'function') {
            console.error('[Orchestrator] World Info functions are not available in the SYSTEM manager.');
            return Promise.resolve('');
        }

        // æ­¥éª¤ 3: ã€å¥å£®çš„äº’æ–¥é”ã€‘åˆ›å»ºä¸€ä¸ªæ–°çš„Promiseä»»åŠ¡ï¼Œå¹¶å°†å…¶é“¾æ¥åˆ°å½“å‰çš„äº’æ–¥é”Promiseé“¾ä¸Šã€‚
        // è¿™ç¡®ä¿äº†æ— è®ºå¤šå°‘ä¸ªèŠ‚ç‚¹å¹¶å‘è°ƒç”¨æ­¤å‡½æ•°ï¼Œå®ƒä»¬éƒ½ä¼šè¢«æ’é˜Ÿï¼Œä¸€æ¬¡åªæ‰§è¡Œä¸€ä¸ªä»»åŠ¡ã€‚
        const taskPromise = this.worldInfoMutex.then(async () => {
            // --- ä»è¿™é‡Œå¼€å§‹ï¼Œæ˜¯å—é”ä¿æŠ¤çš„ä¸´ç•ŒåŒº ---

            console.log(`[Orchestrator] [LOCK ACQUIRED] Preparing isolated WI environment for node: ${module.id}. Books: [${module.worldInfo.join(', ')}]`);

            // æ­¥éª¤ 4: ã€å¤‡ä»½ã€‘ä¿å­˜SillyTavernå½“å‰çš„å…¨å±€WIçŠ¶æ€ã€‚
            const originalState = {
                selected_world_info: SYSTEM.getSelectedWorldInfo(),
                chat_lorebook: SYSTEM.getChatMetadata()?.[SYSTEM.METADATA_KEY],
                // æ³¨æ„ï¼šè¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦å¤‡ä»½æ›´å¤šä¸WIç›¸å…³çš„çŠ¶æ€ã€‚
            };

            let worldInfoString = '';

            try {
                // æ­¥éª¤ 5: ã€æ¸…ç†ã€‘åˆ›å»ºä¸€ä¸ªå¹²å‡€çš„ç¯å¢ƒï¼Œä¸ºå½“å‰èŠ‚ç‚¹å‡†å¤‡èˆå°ã€‚
                SYSTEM.setSelectedWorldInfo([]);
                SYSTEM.setChatMetadata(SYSTEM.METADATA_KEY, undefined);
                if (typeof SYSTEM.unloadAllWorldInfo === 'function') {
                    await SYSTEM.unloadAllWorldInfo();
                }

                // æ­¥éª¤ 6: ã€åŠ è½½ã€‘åªåŠ è½½å½“å‰èŠ‚ç‚¹å®šä¹‰ä¸­æ˜ç¡®è¦æ±‚çš„ä¸–ç•Œä¹¦ã€‚
                SYSTEM.setSelectedWorldInfo(module.worldInfo);
                for (const worldName of module.worldInfo) {
                    try {
                        await SYSTEM.loadWorldInfo(worldName);
                    } catch (error) {
                        console.warn(`[Orchestrator] Failed to load world info "${worldName}" for node ${module.id}:`, error);
                    }
                }
                
                // ç­‰å¾…ä¸€ä¸ªäº‹ä»¶å¾ªç¯ï¼Œç¡®ä¿DOMå’Œå†…éƒ¨çŠ¶æ€æ›´æ–°ç”Ÿæ•ˆã€‚
                await new Promise(resolve => setTimeout(resolve, 10));

                // æ­¥éª¤ 7: ã€æ‰§è¡Œã€‘åœ¨éš”ç¦»ç¯å¢ƒä¸­è®¡ç®—WIã€‚
                const chatMessages = this.rawContext.chat.map(m => m.mes);
                const maxContextSize = this.rawContext.max_context || 4096;
                const globalScanData = {
                    personaDescription: this.rawContext.persona?.description ?? '',
                    characterDescription: this.context.sillyTavern.character?.description ?? '',
                    characterPersonality: this.context.sillyTavern.character?.personality ?? '',
                    scenario: this.rawContext.scenario ?? '',
                    userInput: this.context.sillyTavern.userInput ?? '',
                };

                const wiResult = await SYSTEM.getWorldInfoPrompt(chatMessages, maxContextSize, true, globalScanData);
                worldInfoString = (wiResult?.worldInfoString || '').trim();

                if (worldInfoString) {
                    console.log(`[Orchestrator] Node ${module.id} generated ${worldInfoString.length} chars of WI.`);
                } else {
                    console.warn(`[Orchestrator] Node ${module.id} generated no WI with books [${module.worldInfo.join(', ')}]`);
                }

            } catch (error) {
                console.error(`[Orchestrator] An error occurred during isolated WI calculation for node ${module.id}:`, error);
                worldInfoString = ''; // ç¡®ä¿å‡ºé”™æ—¶è¿”å›ç©ºå­—ç¬¦ä¸²
            } finally {
                // æ­¥éª¤ 8: ã€æ¢å¤ã€‘æ— è®ºæˆåŠŸä¸å¦ï¼Œéƒ½å¿…é¡»æ¢å¤SillyTavernçš„åŸå§‹çŠ¶æ€ï¼Œæ¸…ç†èˆå°ã€‚
                console.log(`[Orchestrator] [LOCK RELEASED] Restoring original WI state after processing node ${module.id}.`);
                SYSTEM.setSelectedWorldInfo(originalState.selected_world_info);
                if (originalState.chat_lorebook !== undefined) {
                    SYSTEM.setChatMetadata(SYSTEM.METADATA_KEY, originalState.chat_lorebook);
                }
                // --- ä¸´ç•ŒåŒºç»“æŸ ---
            }
            
            return worldInfoString;
        });

        // æ­¥éª¤ 9: æ›´æ–°äº’æ–¥é”ï¼Œä½¿å…¶æŒ‡å‘æˆ‘ä»¬åˆšåˆšåˆ›å»ºçš„æ–°ä»»åŠ¡Promiseã€‚
        // è¿™æ ·ï¼Œä¸‹ä¸€ä¸ªè°ƒç”¨è€…å°±å¿…é¡»ç­‰å¾…è¿™ä¸ªä»»åŠ¡å®Œæˆã€‚
        this.worldInfoMutex = taskPromise;

        // æ­¥éª¤ 10: è¿”å›è¿™ä¸ªä»»åŠ¡Promiseã€‚
        // `_executeLLMNode` å°†ä¼š `await` è¿™ä¸ªPromiseï¼Œä»è€Œç­‰å¾…WIè®¡ç®—çš„å®Œæˆã€‚
        return taskPromise;
    }

    _renderPrompt(node, injectedParams = {}) {
        let fullPrompt = '';
        const renderContext = { ...this.context, ...injectedParams };
        for (const slot of node.promptSlots) {
            if (slot.enabled) {
                const renderedContent = slot.content.replace(/{{(.*?)}}/g, (match, path) => {
                    const value = this._resolvePath(path.trim(), renderContext);
                    // [!code focus:start]
                    // ã€å·²ä¿®æ­£ã€‘å¦‚æœè·¯å¾„è§£æç»“æœä¸º undefined æˆ– nullï¼Œåˆ™å°†å…¶è§†ä¸ºç©ºå­—ç¬¦ä¸²ã€‚
                    // è¿™å¯¹äºå¤„ç†å¯é€‰çš„ã€è¢«è·³è¿‡çš„åˆ†æ”¯èŠ‚ç‚¹çš„è¾“å‡ºè‡³å…³é‡è¦ã€‚
                    if (value === undefined || value === null) {
                        return ''; // è¿”å›ç©ºå­—ç¬¦ä¸²ï¼Œè€Œä¸æ˜¯ä¿ç•™å ä½ç¬¦
                    }
                    // [!code focus:end]
                    if (path.trim() === 'sillyTavern.chat') return this._formatChatHistory(value);
                    if (typeof value === 'object') return JSON.stringify(value, null, 2);
                    return String(value);
                });
                fullPrompt += renderedContent + '\n';
            }
        }
        return fullPrompt.trim();
    }

    // [!code focus:99]
    // =================================================================
    // NEW DYNAMIC EXECUTION LOGIC
    // =================================================================

    // [!code focus:start]
    /**
     * ã€å·²ä¿®æ­£ã€‘æ„å»ºå®Œæ•´çš„ä¾èµ–å›¾ã€‚
     * æ­¤ç‰ˆæœ¬ä¼šæ£€æŸ¥æ‰€æœ‰å¯èƒ½å®šä¹‰ä¾èµ–å…³ç³»çš„åœ°æ–¹ã€‚
     */
    _initializeGraph() {
        // æ¸…ç†æ—§çŠ¶æ€
        Object.keys(this.nodes).forEach(key => delete this.nodes[key]);
        this.nodeStates = {};
        this.dependencies.clear();
        this.dependents.clear();

        // æ­¥éª¤ 1: åŠ è½½æ‰€æœ‰èŠ‚ç‚¹çš„åŸºæœ¬ä¿¡æ¯
        for (const nodeDef of this.initialPipeline) {
            if (nodeDef.enabled) {
                this.nodes[nodeDef.id] = JSON.parse(JSON.stringify(nodeDef));
                this.nodeStates[nodeDef.id] = 'pending';
                this.dependencies.set(nodeDef.id, new Set());
                this.dependents.set(nodeDef.id, new Set());
            }
        }

        // æ­¥éª¤ 2: éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œä¸ºå®ƒä»¬æ·»åŠ ä¾èµ–
        const dependencyRegex = /{{\s*outputs\.([\w.-]+)\s*}}/g;

        for (const nodeId in this.nodes) {
            const node = this.nodes[nodeId];
            const nodeDependencies = this.dependencies.get(nodeId);

            // a. ä»æ¨¡æ¿/promptä¸­æå– '{{outputs...}}' ä¾èµ–
            const contentToCheck = JSON.stringify(node.promptSlots || '');
            for (const match of contentToCheck.matchAll(dependencyRegex)) {
                if (this.nodes[match[1]]) {
                    nodeDependencies.add(match[1]);
                }
            }

            // b. ã€æ–°å¢ã€‘æ£€æŸ¥ç‰¹å®šèŠ‚ç‚¹ç±»å‹çš„å‚æ•°ä¾èµ–
            const params = node.params || {};
            if (params.sourceNode && this.nodes[params.sourceNode]) {
                nodeDependencies.add(params.sourceNode);
            }
            if (params.sourceNodeIds && Array.isArray(params.sourceNodeIds)) {
                params.sourceNodeIds.forEach(id => {
                    if (this.nodes[id]) nodeDependencies.add(id);
                });
            }

            // c. ã€æ–°å¢ã€‘æ£€æŸ¥MapNodeå’ŒRouterçš„ç‰¹å®šä¾èµ–
            if (node.type === 'map' && node.inputListRef) {
                const listSourceMatch = node.inputListRef.match(/outputs\.([\w.-]+)/);
                if (listSourceMatch && this.nodes[listSourceMatch[1]]) {
                    nodeDependencies.add(listSourceMatch[1]);
                }
            }
            if (node.type === 'router' && node.condition) {
                const conditionMatch = node.condition.match(/outputs\.([\w.-]+)/);
                if (conditionMatch && this.nodes[conditionMatch[1]]) {
                    nodeDependencies.add(conditionMatch[1]);
                }
            }
        }

        // æ­¥éª¤ 3: ä¸“é—¨å¤„ç†ç»“æ„æ€§ä¾èµ–ï¼ˆåœ¨æ‰€æœ‰å…¶ä»–ä¾èµ–å»ºç«‹ä¹‹åï¼‰
        for (const nodeId in this.nodes) {
            const node = this.nodes[nodeId];

            // a. JoinNode ä¾èµ–äº MapNode
            if (node.type === 'map' && node.joinNode) {
                const joinNodeId = node.joinNode;
                if (this.dependencies.has(joinNodeId)) {
                    this.dependencies.get(joinNodeId).add(nodeId);
                }
            }

            // b. è·¯ç”±å™¨çš„åˆ†æ”¯ç›®æ ‡ä¾èµ–äºè·¯ç”±å™¨æœ¬èº«
            if (node.type === 'router' && node.routes) {
                for (const routeKey in node.routes) {
                    const targetNodeId = node.routes[routeKey];
                    if (this.dependencies.has(targetNodeId)) {
                        this.dependencies.get(targetNodeId).add(nodeId);
                    }
                }
            }
        }
        // [!code focus:end]

        // æ­¥éª¤ 4: æ„å»ºåå‘ä¾èµ–å›¾ (dependents)
        for (const [nodeId, deps] of this.dependencies.entries()) {
            for (const depId of deps) {
                if (this.dependents.has(depId)) {
                    this.dependents.get(depId).add(nodeId);
                }
            }
        }

        console.log('[GraphInit] Dependency graph constructed:', this.dependencies);
    }

    async _executeNode(nodeId) {
        const node = this.nodes[nodeId];
        if (!node) {
            throw new Error(`Node with ID "${nodeId}" not found.`);
        }

        console.log(`[Orchestrator] > Executing ${node.type.toUpperCase()} node: ${node.id} (${node.name})`);

        switch (node.type) {
            case 'llm':
                this.context.outputs[node.id] = await this._executeLLMNode(node);
                break;
            case 'function':
                this.context.outputs[node.id] = await this._executeFunctionNode(node);
                break;
            case 'router':
                // Routerçš„æ‰§è¡Œåªåšå†³ç­–ï¼Œä¸æ”¹å˜å›¾çš„çŠ¶æ€
                await this._executeRouterNode(node);
                break;
            case 'map':
                await this._executeMapNode(node);
                break;
            default:
                throw new Error(`Unsupported node type: "${node.type}"`);
        }
    }

    async _executeLLMNode(node) {
        const nodeLabel = `${node.id} (${node.name})`;
        console.log(`[Pipeline] ğŸ¯ Executing LLM node: ${nodeLabel}`);
        
        // è®¡ç®—ä¸–ç•Œä¹¦ä¿¡æ¯
        const worldInfoContent = await this._calculateModuleWorldInfo(node);
        this.context.module = { worldInfo: worldInfoContent };
        const finalPrompt = this._renderPrompt(node, node.injectedParams);

        // =================== è¯¦ç»†çš„LLMè°ƒç”¨é¢„è§ˆ ===================
        console.log(`[Pipeline] ================== LLM CALL OVERVIEW: ${nodeLabel} ==================`);
        console.log(`[Pipeline] ï¿½ Node: ${nodeLabel}`);
        console.log(`[Pipeline] ğŸ¤– Model: ${node.llm.provider}/${node.llm.model}`);
        console.log(`[Pipeline] âš™ï¸  Config:`, {
            temperature: node.llm.temperature,
            maxOutputTokens: node.llm.maxOutputTokens,
            topP: node.llm.topP
        });
        console.log(`[Pipeline] ğŸ“ Prompt Length: ${finalPrompt.length} characters`);
        console.log(`[Pipeline] ğŸŒ World Info Length: ${worldInfoContent ? worldInfoContent.length : 0} characters`);
        console.log(`[Pipeline] â° Timestamp: ${new Date().toISOString()}`);
        console.log(`[Pipeline] ğŸ“ Full Prompt:`);
        console.log(finalPrompt);
        console.log(`[Pipeline] ================== PROMPT END ==================`);

        try {
            const startTime = Date.now();
            const result = await dispatchLLM(finalPrompt, node.llm);
            const duration = Date.now() - startTime;

            // =================== è¯¦ç»†çš„LLMå“åº”æŠ¥å‘Š ===================
            console.log(`[Pipeline] ================== LLM RESPONSE REPORT: ${nodeLabel} ==================`);
            console.log(`[Pipeline] ğŸ“‹ Node: ${nodeLabel}`);
            console.log(`[Pipeline] â±ï¸  Duration: ${duration}ms`);
            console.log(`[Pipeline] ğŸ“ Response Length: ${result ? result.length : 0} characters`);
            
            if (!result || result.trim().length === 0) {
                console.warn(`[Pipeline] âš ï¸  WARNING: EMPTY RESPONSE`);
                console.warn(`[Pipeline] ğŸ” Check detailed API analysis above for diagnostic information`);
                console.log(`[Pipeline] ğŸ“ Response Content: (EMPTY)`);
            } else {
                console.log(`[Pipeline] âœ… Success: Generated ${result.length} characters`);
                console.log(`[Pipeline] ğŸ“ Full Response:`);
                console.log(result);
            }
            
            console.log(`[Pipeline] ================== RESPONSE END ==================`);

            return result || '';
            
        } catch (error) {
            console.error(`[Pipeline] ================== LLM ERROR REPORT: ${nodeLabel} ==================`);
            console.error(`[Pipeline] âŒ Error: ${error.message}`);
            console.error(`[Pipeline] ğŸ” Full Error:`, error);
            console.error(`[Pipeline] ================== ERROR END ==================`);
            throw error;
        }
    }


    async _executeFunctionNode(node) {
        return executeFunction(node.functionName, this.context, node.params);
    }

    async _executeRouterNode(node) {
        const conditionValueRaw = this._resolvePath(node.condition.replace(/{{|}}/g, '').trim(), this.context);
        const conditionValue = String(conditionValueRaw).trim().toLowerCase();

        let chosenNextNodeId = null;
        for (const routeKey in node.routes) {
            // æ”¯æŒç”¨ 'default' ä½œä¸ºå¤‡ç”¨è·¯ç”±
            if (routeKey.toLowerCase() === conditionValue) {
                chosenNextNodeId = node.routes[routeKey];
                break;
            }
        }

        // å¦‚æœæ²¡æœ‰ç²¾ç¡®åŒ¹é…ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ 'default' è·¯ç”±
        if (!chosenNextNodeId && node.routes.default) {
            chosenNextNodeId = node.routes.default;
        }

        console.log(`[Router:${node.id}] Condition value is "${conditionValue}". Routing to -> ${chosenNextNodeId || 'end of branch'}.`);

        // å°†å†³ç­–ç»“æœå­˜èµ·æ¥ï¼Œä»¥ä¾¿ run å‡½æ•°ä½¿ç”¨
        this.context.outputs[node.id] = { decision: chosenNextNodeId };
    }


    async _executeMapNode(node) {
        const list = this._resolvePath(node.inputListRef.replace(/{{|}}/g, '').trim(), this.context);
        const joinNodeId = node.joinNode;

        if (!Array.isArray(list) || list.length === 0) {
            console.warn(`[MapNode:${node.id}] Input list is empty or not an array. Informing join node.`);
            if (joinNodeId && this.nodes[joinNodeId]) {
                if (!this.nodes[joinNodeId].params) {
                    this.nodes[joinNodeId].params = {};
                }
                this.nodes[joinNodeId].params.sourceNodeIds = [];
            }
            return;
        }

        const templateNode = node.templateNode;
        const dynamicNodeIds = [];

        for (let i = 0; i < list.length; i++) {
            const item = list[i];
            const newNodeId = `${templateNode.id}_${i}`;

            const newNode = JSON.parse(JSON.stringify(templateNode));
            newNode.id = newNodeId;
            newNode.name = `${templateNode.name} for "${item}"`;
            newNode.injectedParams = { item: item };
            newNode.enabled = true;

            this.nodes[newNodeId] = newNode;
            this.nodeStates[newNodeId] = 'pending';
            dynamicNodeIds.push(newNodeId);

            // åŠ¨æ€èŠ‚ç‚¹çš„ä¾èµ–æ˜¯ Map èŠ‚ç‚¹æœ¬èº«
            this.dependencies.set(newNodeId, new Set([node.id]));
            if (!this.dependents.has(node.id)) this.dependents.set(node.id, new Set());
            this.dependents.get(node.id).add(newNodeId);

            console.log(`[MapNode:${node.id}] Spawned dynamic node: ${newNodeId}`);
        }

        if (joinNodeId && this.nodes[joinNodeId]) {
            const joinNode = this.nodes[joinNodeId];
            const joinNodeDeps = this.dependencies.get(joinNodeId) || new Set();

            // JoinNode ä¾èµ–äºæ‰€æœ‰åŠ¨æ€ç”Ÿæˆçš„èŠ‚ç‚¹
            dynamicNodeIds.forEach(id => {
                joinNodeDeps.add(id);
                // åŒæ—¶ï¼Œå»ºç«‹åå‘ä¾èµ–
                if (!this.dependents.has(id)) this.dependents.set(id, new Set());
                this.dependents.get(id).add(joinNodeId);
            });

            this.dependencies.set(joinNodeId, joinNodeDeps);

            if (!joinNode.params) joinNode.params = {};
            joinNode.params.sourceNodeIds = dynamicNodeIds; // æ³¨å…¥åŠ¨æ€IDåˆ—è¡¨
        }
    }

    async run() {
        console.log('[Orchestrator V2] Starting dynamic graph execution...');
        this._initializeGraph();

        const inDegree = new Map();
        for (const nodeId in this.nodes) {
            inDegree.set(nodeId, this.dependencies.get(nodeId)?.size || 0);
        }

        let executionQueue = Object.keys(this.nodes).filter(nodeId => inDegree.get(nodeId) === 0);
        let completedOrSkippedCount = 0;

        while (executionQueue.length > 0) {
            console.log(`[Orchestrator] Executing parallel batch of ${executionQueue.length} nodes:`, executionQueue.map(id => this.nodes[id]?.name || id));

            const currentBatch = [...executionQueue];
            executionQueue = [];

            const promises = currentBatch.map(async (nodeId) => {
                try {
                    // é˜²å¾¡æ€§æ£€æŸ¥ï¼Œé˜²æ­¢è·³è¿‡çš„èŠ‚ç‚¹è¢«é”™è¯¯æ‰§è¡Œ
                    if (this.nodeStates[nodeId] !== 'pending') return;

                    this.nodeStates[nodeId] = 'running';
                    await this._executeNode(nodeId);
                    this.nodeStates[nodeId] = 'completed';
                } catch (error) {
                    this.nodeStates[nodeId] = 'failed';
                    const nodeName = this.nodes[nodeId]?.name || 'Unknown Node';
                    console.error(`Execution failed at node ${nodeName} (${nodeId}):`, error);
                    // æŠ›å‡ºé”™è¯¯ä»¥åœæ­¢æ•´ä¸ªæµç¨‹
                    throw new Error(`Execution failed at node ${nodeName}: ${error.message}`);
                }
            });

            await Promise.all(promises);

            // [!code focus:start]
            // ========================= æ ¸å¿ƒä¿®æ­£é€»è¾‘ START =========================
            // åœ¨å¤„ç†ä¸‹æ¸¸èŠ‚ç‚¹ä¹‹å‰ï¼Œæ£€æŸ¥åˆšåˆšå®Œæˆçš„æ‰¹æ¬¡ä¸­æ˜¯å¦æœ‰MapNodeã€‚
            // å¦‚æœæœ‰ï¼Œå›¾çš„ç»“æ„å·²ç»æ”¹å˜ï¼Œæˆ‘ä»¬å¿…é¡»æ›´æ–°inDegreeæ˜ å°„ã€‚
            for (const completedNodeId of currentBatch) {
                const node = this.nodes[completedNodeId];
                if (node.type === 'map') {
                    const joinNodeId = node.joinNode;
                    const dynamicNodeIds = this.nodes[joinNodeId]?.params?.sourceNodeIds || [];

                    // 1. ä¸ºæ‰€æœ‰æ–°ç”Ÿæˆçš„åŠ¨æ€èŠ‚ç‚¹è®¾ç½®åˆå§‹inDegree
                    for (const dynamicNodeId of dynamicNodeIds) {
                        // æ–°èŠ‚ç‚¹åœ¨åˆ›å»ºæ—¶å·²è®¾ç½®ä¾èµ–ï¼Œè¿™é‡Œç›´æ¥ä» this.dependencies è·å–
                        const initialDegree = this.dependencies.get(dynamicNodeId)?.size || 0;
                        inDegree.set(dynamicNodeId, initialDegree);

                        // ã€è¡¥å……æ£€æŸ¥ã€‘å¦‚æœæ–°èŠ‚ç‚¹çš„å…¥åº¦ä¸º0ï¼Œå®ƒåº”è¯¥è¢«åŠ å…¥ä¸‹ä¸€ä¸ªæ‰§è¡Œé˜Ÿåˆ—
                        // ä½†åœ¨ä½ çš„è®¾è®¡ä¸­ï¼ŒåŠ¨æ€èŠ‚ç‚¹çš„ä¾èµ–æ˜¯MapNodeæœ¬èº«ï¼Œæ‰€ä»¥å®ƒçš„å…¥åº¦è‡³å°‘ä¸º1ï¼Œ
                        // å¹¶ä¸”ä¼šåœ¨MapNodeå®Œæˆåé€’å‡ï¼Œæ‰€ä»¥è¿™é‡Œçš„é€»è¾‘æ˜¯å®‰å…¨çš„ã€‚
                    }

                    // 2. æ›´æ–°JoinNodeçš„inDegreeï¼Œå› ä¸ºå®ƒè·å¾—äº†æ–°çš„ä¾èµ–
                    if (joinNodeId && this.nodes[joinNodeId]) {
                        // ã€é‡è¦ä¿®æ­£ã€‘è¿™é‡Œçš„é€»è¾‘éœ€è¦è°ƒæ•´ã€‚ä¸åº”è¯¥æ˜¯ oldDegree + newDegreeã€‚
                        // åº”è¯¥æ˜¯ç›´æ¥ä» this.dependencies é‡æ–°è®¡ç®—ã€‚
                        // ä½†è€ƒè™‘åˆ°æ‹“æ‰‘æ’åºçš„é€’å‡æ€§è´¨ï¼Œæ›´å¥½çš„æ–¹æ³•æ˜¯å¢åŠ å®ƒçš„ inDegreeã€‚
                        const currentDegree = inDegree.get(joinNodeId) || 0;
                        inDegree.set(joinNodeId, currentDegree + dynamicNodeIds.length);
                        console.log(`[GraphUpdate] JoinNode ${joinNodeId} inDegree increased by ${dynamicNodeIds.length}, new total: ${inDegree.get(joinNodeId)}`);
                    }
                }
            }
            // ========================= æ ¸å¿ƒä¿®æ­£é€»è¾‘ END =========================
            // [!code focus:end]


            let nodesToProcessForDependents = new Set(currentBatch);

            // å¤„ç†åˆšåˆšå®Œæˆçš„èŠ‚ç‚¹ï¼Œç‰¹åˆ«æ˜¯Router
            for (const completedNodeId of currentBatch) {
                const node = this.nodes[completedNodeId];
                if (node.type === 'router') {
                    const decision = this.context.outputs[completedNodeId]?.decision;
                    for (const routeKey in node.routes) {
                        const targetNodeId = node.routes[routeKey];
                        if (targetNodeId !== decision && this.nodes[targetNodeId] && this.nodeStates[targetNodeId] === 'pending') {
                            this.nodeStates[targetNodeId] = 'skipped';
                            nodesToProcessForDependents.add(targetNodeId);
                            console.log(`[Router:${node.id}] Skipped node ${targetNodeId}`);
                        }
                    }
                }
            }

            completedOrSkippedCount += nodesToProcessForDependents.size;

            // ä¸ºæ‰€æœ‰æ–°å®Œæˆæˆ–è·³è¿‡çš„èŠ‚ç‚¹ï¼Œæ›´æ–°å…¶ä¸‹æ¸¸èŠ‚ç‚¹çš„å…¥åº¦
            for (const processedNodeId of nodesToProcessForDependents) {
                const dependents = this.dependents.get(processedNodeId) || new Set();

                for (const dependentId of dependents) {
                    if (this.nodeStates[dependentId] === 'pending') {
                        const newDegree = (inDegree.get(dependentId) || 1) - 1;
                        inDegree.set(dependentId, newDegree);

                        if (newDegree === 0) {
                            executionQueue.push(dependentId);
                        }
                    }
                }
            }
        }

        const totalNodes = Object.keys(this.nodes).length;
        if (completedOrSkippedCount < totalNodes) {
            const unexecutedNodes = Object.keys(this.nodes).filter(id => this.nodeStates[id] === 'pending');
            const unexecutedNames = unexecutedNodes.map(id => this.nodes[id]?.name || id).join(', ');
            console.error(`[Orchestrator] Execution incomplete. ${unexecutedNodes.length} nodes were not executed, possibly due to a dependency cycle or graph error. Unexecuted:`, unexecutedNames);
            throw new Error(`Execution failed. Unexecuted nodes: ${unexecutedNames}`);
        }

        console.log("[Orchestrator] Pipeline finished. All outputs:", this.context.outputs);
        const finalOutput = this.context.outputs[this.finalOutputNodeId];
        return finalOutput || "Pipeline completed, but no final output was designated or the final node produced no output.";
    }
}
```

### utils/logging_example.js
```
// src/utils/logging_example.js

/**
 * æ—¥å¿—ç³»ç»Ÿä½¿ç”¨ç¤ºä¾‹å’Œé…ç½®æŒ‡å—
 */

import { DEBUG_CONFIG, setLogLevel } from './debug_config.js';
import { llmLogger } from './llm_logger.js';

// =============================================================================
// ä½¿ç”¨ç¤ºä¾‹
// =============================================================================

/**
 * ç¤ºä¾‹1ï¼šç”Ÿäº§ç¯å¢ƒé…ç½®
 * åªæ˜¾ç¤ºè­¦å‘Šå’Œé”™è¯¯ï¼Œä¿æŒæ—¥å¿—ç®€æ´
 */
function setupProductionLogging() {
    setLogLevel('WARN');
    DEBUG_CONFIG.LLM_LOGS.INCLUDE_FULL_PROMPT = false;
    DEBUG_CONFIG.LLM_LOGS.INCLUDE_FULL_RESPONSE = false;
    
    console.log('âœ… Production logging configured - minimal output');
}

/**
 * ç¤ºä¾‹2ï¼šå¼€å‘ç¯å¢ƒé…ç½®
 * æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ï¼Œä¾¿äºè°ƒè¯•
 */
function setupDevelopmentLogging() {
    setLogLevel('DEBUG');
    DEBUG_CONFIG.LLM_LOGS.INCLUDE_FULL_PROMPT = true;
    DEBUG_CONFIG.LLM_LOGS.INCLUDE_FULL_RESPONSE = true;
    
    console.log('âœ… Development logging configured - verbose output');
}

/**
 * ç¤ºä¾‹3ï¼šæ•…éšœæ’é™¤é…ç½®
 * ä¸“æ³¨äºé”™è¯¯åˆ†æå’Œç©ºå“åº”è¯Šæ–­
 */
function setupTroubleshootingLogging() {
    setLogLevel('INFO');
    DEBUG_CONFIG.LLM_LOGS.EMPTY_RESPONSE_ANALYSIS = true;
    DEBUG_CONFIG.LLM_LOGS.INCLUDE_API_DETAILS = true;
    
    console.log('âœ… Troubleshooting logging configured - focused on issues');
}

/**
 * ç¤ºä¾‹4ï¼šé™é»˜æ¨¡å¼
 * åªè®°å½•ä¸¥é‡é”™è¯¯
 */
function setupSilentLogging() {
    setLogLevel('ERROR');
    Object.keys(DEBUG_CONFIG).forEach(key => {
        if (typeof DEBUG_CONFIG[key] === 'object') {
            Object.keys(DEBUG_CONFIG[key]).forEach(subKey => {
                if (subKey !== 'ENABLED') {
                    DEBUG_CONFIG[key][subKey] = false;
                }
            });
        }
    });
    
    console.log('âœ… Silent logging configured - errors only');
}

// =============================================================================
// å¿«é€Ÿé…ç½®å‡½æ•°
// =============================================================================

/**
 * æ ¹æ®ç¯å¢ƒè‡ªåŠ¨é…ç½®æ—¥å¿—
 */
export function autoConfigureLogging() {
    const isDevelopment = process.env.NODE_ENV === 'development' || 
                         window.location.hostname === 'localhost';
    
    if (isDevelopment) {
        setupDevelopmentLogging();
    } else {
        setupProductionLogging();
    }
}

/**
 * è¿è¡Œæ—¶åˆ‡æ¢æ—¥å¿—çº§åˆ«
 */
export function switchLoggingMode(mode) {
    switch (mode.toLowerCase()) {
        case 'production':
        case 'prod':
            setupProductionLogging();
            break;
        case 'development':
        case 'dev':
            setupDevelopmentLogging();
            break;
        case 'troubleshoot':
        case 'debug':
            setupTroubleshootingLogging();
            break;
        case 'silent':
        case 'quiet':
            setupSilentLogging();
            break;
        default:
            console.warn(`Unknown logging mode: ${mode}`);
            console.log('Available modes: production, development, troubleshoot, silent');
    }
}

// =============================================================================
// æµè§ˆå™¨æ§åˆ¶å°è¾…åŠ©å‡½æ•°
// =============================================================================

/**
 * åœ¨æµè§ˆå™¨æ§åˆ¶å°ä¸­å¯ç”¨çš„è°ƒè¯•å‡½æ•°
 */
if (typeof window !== 'undefined') {
    window.HevnoLogging = {
        // å¿«é€Ÿåˆ‡æ¢æ—¥å¿—æ¨¡å¼
        setMode: switchLoggingMode,
        
        // è·å–å½“å‰é…ç½®
        getConfig: () => DEBUG_CONFIG,
        
        // åˆ†ææœ€è¿‘çš„ç©ºå“åº”ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
        analyzeLastEmpty: () => {
            console.log('This would analyze the last empty response if tracking was enabled');
        },
        
        // æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
        help: () => {
            console.log(`
ğŸ”§ Hevno Logging Controls:

HevnoLogging.setMode('production')    - ç”Ÿäº§æ¨¡å¼ï¼ˆç®€æ´æ—¥å¿—ï¼‰
HevnoLogging.setMode('development')   - å¼€å‘æ¨¡å¼ï¼ˆè¯¦ç»†æ—¥å¿—ï¼‰
HevnoLogging.setMode('troubleshoot')  - æ•…éšœæ’é™¤æ¨¡å¼
HevnoLogging.setMode('silent')        - é™é»˜æ¨¡å¼ï¼ˆä»…é”™è¯¯ï¼‰

HevnoLogging.getConfig()              - æŸ¥çœ‹å½“å‰é…ç½®
HevnoLogging.help()                   - æ˜¾ç¤ºæ­¤å¸®åŠ©

Example:
  HevnoLogging.setMode('dev')         - åˆ‡æ¢åˆ°å¼€å‘æ¨¡å¼
            `);
        }
    };
    
    console.log('ğŸ”§ Hevno logging controls available. Type HevnoLogging.help() for commands.');
}

// =============================================================================
// è‡ªåŠ¨åˆå§‹åŒ–
// =============================================================================

// è‡ªåŠ¨é…ç½®ï¼ˆå¦‚æœæ²¡æœ‰æ‰‹åŠ¨é…ç½®çš„è¯ï¼‰
if (typeof window !== 'undefined' && !window.HEVNO_LOGGING_CONFIGURED) {
    autoConfigureLogging();
    window.HEVNO_LOGGING_CONFIGURED = true;
}

```

### utils/llm_logger.js
```
// src/utils/llm_logger.js

import { DEBUG_CONFIG, shouldLog, getLogConfig } from './debug_config.js';

/**
 * LLMè°ƒç”¨ä¸“ç”¨åˆ†æå·¥å…·
 * ä¸“æ³¨äºé—®é¢˜è¯Šæ–­å’Œæ·±åº¦åˆ†æï¼Œä¸é‡å¤åŸºç¡€æ—¥å¿—
 */
export class LLMLogger {
    
    /**
     * è®°å½•ç©ºå“åº”çš„è¯¦ç»†åˆ†æï¼ˆè¿™æ˜¯æœ€é‡è¦çš„åŠŸèƒ½ï¼‰
     */
    static logEmptyResponse(sessionId, prompt, llmConfig, apiResponse, context = {}) {
        const timestamp = new Date().toISOString();
        
        console.group(`ğŸ” [LLM-Analysis] EMPTY RESPONSE - ${sessionId} - ${timestamp}`);
        console.warn('âš ï¸  Empty response detected, analyzing possible causes...');
        
        // åŸºæœ¬ä¿¡æ¯
        console.log('ğŸ“‹ Context:', {
            promptLength: prompt.length,
            model: llmConfig.model,
            temperature: llmConfig.temperature,
            maxTokens: llmConfig.maxOutputTokens,
            apiKey: context.apiKey ? `...${context.apiKey.slice(-4)}` : 'unknown'
        });
        
        // åˆ†æAPIå“åº”ç»“æ„
        console.group('ğŸ•µï¸  API Response Analysis:');
        
        if (!apiResponse.candidates || apiResponse.candidates.length === 0) {
            console.warn('âŒ No candidates returned by API - possible request rejection');
        } else {
            console.log(`âœ… ${apiResponse.candidates.length} candidate(s) available`);
            
            const candidate = apiResponse.candidates[0];
            if (candidate.finishReason !== 'STOP') {
                console.warn(`âŒ Unusual finish reason: ${candidate.finishReason}`);
                if (candidate.finishReason === 'SAFETY') {
                    console.warn('ğŸ›¡ï¸  Content filtered by safety system');
                } else if (candidate.finishReason === 'MAX_TOKENS') {
                    console.warn('ğŸ“ Response truncated due to token limit');
                }
            }
        }
        
        if (apiResponse.promptFeedback) {
            console.warn('ğŸ›¡ï¸  Prompt feedback (content policy):');
            console.warn(apiResponse.promptFeedback);
        }
        
        if (apiResponse.safetyRatings && apiResponse.safetyRatings.length > 0) {
            const blockedRatings = apiResponse.safetyRatings.filter(rating => 
                rating.probability === 'HIGH' || rating.probability === 'MEDIUM'
            );
            if (blockedRatings.length > 0) {
                console.warn('ğŸš¨ Safety concerns detected:');
                blockedRatings.forEach(rating => {
                    console.warn(`  - ${rating.category}: ${rating.probability}`);
                });
            }
        }
        
        console.groupEnd();
        
        // åˆ†æå¯èƒ½çš„åŸå› 
        console.group('ğŸ’¡ Possible Solutions:');
        
        if (prompt.length > 30000) {
            console.log('ğŸ“ Try reducing prompt length (current: >30k chars)');
        }
        
        if (llmConfig.maxOutputTokens && llmConfig.maxOutputTokens < 100) {
            console.log('ğŸ”§ Try increasing maxOutputTokens (current: <100)');
        }
        
        if (llmConfig.temperature === 0) {
            console.log('ğŸ² Try increasing temperature for more creativity');
        }
        
        if (apiResponse.promptFeedback || (apiResponse.safetyRatings && apiResponse.safetyRatings.length > 0)) {
            console.log('ğŸ“ Try rephrasing prompt to avoid content policy triggers');
        }
        
        if (context.retryAttempt > 1) {
            console.log('ğŸ”„ Consider checking API key quota and status');
        }
        
        console.groupEnd();
        console.groupEnd();
    }
    
    /**
     * ç”Ÿæˆä¼šè¯IDç”¨äºè·Ÿè¸ªå•æ¬¡LLMè°ƒç”¨
     */
    static generateSessionId() {
        return Math.random().toString(36).substring(2, 8).toUpperCase();
    }
    
    /**
     * åˆ†æAPIé”™è¯¯
     */
    static analyzeError(error, context = {}) {
        console.group('ğŸ” [LLM-Analysis] ERROR ANALYSIS');
        
        if (error.status === 429) {
            console.error('ğŸš« Rate limit exceeded - API quota exhausted');
            console.log('ğŸ’¡ Solutions: Wait for quota reset, use different API key, or reduce request frequency');
        } else if (error.status === 401 || error.status === 403) {
            console.error('ğŸ”‘ Authentication/Authorization failed');
            console.log('ğŸ’¡ Solutions: Check API key validity, permissions, and billing status');
        } else if (error.status >= 500) {
            console.error('ğŸ”¥ Server error - API service issue');
            console.log('ğŸ’¡ Solutions: Retry after delay, check API status page');
        } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
            console.error('ğŸŒ Network connectivity issue');
            console.log('ğŸ’¡ Solutions: Check internet connection, proxy settings, firewall');
        } else {
            console.error(`â“ Unknown error: ${error.name} - ${error.message}`);
        }
        
        if (context.apiKey) {
            console.log(`ğŸ”‘ API Key: ...${context.apiKey.slice(-4)}`);
        }
        
        console.groupEnd();
    }
}

// å…¨å±€å¯ç”¨çš„ä¾¿æ·å‡½æ•°
export const llmLogger = LLMLogger;

```

### utils/debug_config.js
```
// src/utils/debug_config.js

/**
 * è°ƒè¯•å’Œæ—¥å¿—é…ç½®
 * ç”¨äºæ§åˆ¶æ•´ä¸ªç³»ç»Ÿçš„æ—¥å¿—è¾“å‡ºçº§åˆ«
 */
export const DEBUG_CONFIG = {
    // æ—¥å¿—çº§åˆ«: 'DEBUG', 'INFO', 'WARN', 'ERROR'
    LOG_LEVEL: 'DEBUG',
    
    // LLMç›¸å…³æ—¥å¿—
    LLM_LOGS: {
        ENABLED: true,
        INCLUDE_FULL_PROMPT: true,
        INCLUDE_FULL_RESPONSE: true,
        INCLUDE_API_DETAILS: true,
        EMPTY_RESPONSE_ANALYSIS: true
    },
    
    // èŠ‚ç‚¹æ‰§è¡Œæ—¥å¿—
    NODE_EXECUTION: {
        ENABLED: true,
        INCLUDE_TIMING: true,
        INCLUDE_CONTEXT: true
    },
    
    // APIå¯†é’¥ç®¡ç†æ—¥å¿—
    API_KEY_MANAGEMENT: {
        ENABLED: true,
        INCLUDE_KEY_ROTATION: true,
        INCLUDE_FAILURE_DETAILS: true
    },
    
    // ä¸–ç•Œä¹¦æ—¥å¿—
    WORLD_INFO: {
        ENABLED: true,
        INCLUDE_LOADING_DETAILS: true,
        INCLUDE_MUTEX_INFO: true
    }
};

/**
 * è®¾ç½®æ—¥å¿—çº§åˆ«
 */
export function setLogLevel(level) {
    DEBUG_CONFIG.LOG_LEVEL = level;
    console.log(`[Debug Config] Log level set to: ${level}`);
}

/**
 * æ£€æŸ¥æ˜¯å¦åº”è¯¥è®°å½•ç‰¹å®šçº§åˆ«çš„æ—¥å¿—
 */
export function shouldLog(level) {
    const levels = ['DEBUG', 'INFO', 'WARN', 'ERROR'];
    const currentLevelIndex = levels.indexOf(DEBUG_CONFIG.LOG_LEVEL);
    const requestedLevelIndex = levels.indexOf(level);
    return requestedLevelIndex >= currentLevelIndex;
}

/**
 * è·å–ç‰¹å®šåŠŸèƒ½çš„æ—¥å¿—é…ç½®
 */
export function getLogConfig(feature) {
    return DEBUG_CONFIG[feature] || { ENABLED: false };
}

```

### data/defaultPipeline.js
```
export const defaultPipeline = [
    // =================================================================
    // é˜¶æ®µ 1: æ•…äº‹åˆ›ä½œä¸è§’è‰²è¯†åˆ«
    // =================================================================
    
    // èŠ‚ç‚¹ 1: æ•…äº‹ç”Ÿæˆå™¨
    {
        "id": "story_generator",
        "name": "1. æ•…äº‹ç”Ÿæˆå™¨",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.8 },
        "worldInfo": ["world_info"], // ä½¿ç”¨æ­£ç¡®çš„ä¸–ç•Œä¹¦åç§°ï¼ˆä¸å¸¦.jsonæ‰©å±•åï¼‰
        "promptSlots": [{
            "enabled": true,
            "content": "ä½ æ˜¯ä¸€ä½å¯Œæœ‰æƒ³è±¡åŠ›çš„å°è¯´å®¶ã€‚è¯·æ ¹æ®ç”¨æˆ·çš„è¯·æ±‚ï¼Œåˆ›ä½œä¸€ä¸ªåŒ…å«å¤šä¸ªè§’è‰²çš„ã€æˆå‰§æ€§çš„ä¸­ä¸–çºªå¥‡å¹»å°è¯´ã€‚åœºæ™¯æè¿°éœ€è¦ç”ŸåŠ¨ï¼Œå¹¶æ˜ç¡®ä»‹ç»è‡³å°‘ä¸¤åå‡ºåœºè§’è‰²çš„åå­—å’Œç®€è¦ç‰¹å¾ï¼Œä¸ºåç»­æƒ…èŠ‚å‘å±•åŸ‹ä¸‹ä¼ç¬”ã€‚\n\nç”¨æˆ·è¯·æ±‚:\n{{sillyTavern.userInput}}\n\n# ä¸–ç•Œä¿¡æ¯:{{module.worldInfo}}\n\nä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸€æ®µ200å­—ä»¥ä¸Šçš„æµç•…çš„æ•…äº‹ï¼Œä¸èƒ½åŒ…å«ä»»ä½•æ§åˆ¶æ–‡æœ¬æˆ–è€…æŒ‡ä»¤ã€‚"
        }]
    },
    
    // èŠ‚ç‚¹ 2: è§’è‰²è¯†åˆ«LLM
    {
        "id": "character_identifier_llm",
        "name": "2. LLMè¯†åˆ«è§’è‰²",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.1 },
        "promptSlots": [{
            "enabled": true,
            "content": "åˆ†æå·¥å…·ï¼šä¸¥æ ¼æŒ‰ç…§ 'Characters: è§’è‰²A, è§’è‰²B, è§’è‰²C' çš„æ ¼å¼ï¼Œä»ä»¥ä¸‹æ–‡æœ¬ä¸­æå–æ‰€æœ‰è¢«å‘½åçš„è§’è‰²ã€‚å¦‚æœä¸€ä¸ªè§’è‰²éƒ½æ²¡æœ‰ï¼Œå¿…é¡»è¾“å‡º 'Characters: None'ã€‚ä¸è¦æ·»åŠ ä»»ä½•å…¶ä»–è§£é‡Šæˆ–å‰è¨€ã€‚\n\næ–‡æœ¬ï¼š\n{{outputs.story_generator}}"
        }]
    },

    // èŠ‚ç‚¹ 3: è§£æè§’è‰²åˆ—è¡¨ (ä½¿ç”¨ä¿ç•™çš„ä¾¿åˆ©å‡½æ•°)
    // å°½ç®¡æœ‰æ›´é€šç”¨çš„regexExtractï¼Œä½†parseCharacterListå¯¹äºè¿™ä¸ªå¸¸è§ä»»åŠ¡æ›´æ–¹ä¾¿ã€‚
    {
        "id": "parse_character_list",
        "name": "3. è§£æè§’è‰²åˆ—è¡¨",
        "enabled": true,
        "type": "function",
        "functionName": "parseCharacterList",
        "params": { "sourceNode": "character_identifier_llm" }
    },

    // =================================================================
    // é˜¶æ®µ 2: åŠ¨æ€è§’è‰²è¡ŒåŠ¨åˆ†æ (Map/Reduce æ¨¡å¼)
    // =================================================================

    // èŠ‚ç‚¹ 4: MapèŠ‚ç‚¹ - ä¸ºæ¯ä¸ªè§’è‰²ç”Ÿæˆè¡ŒåŠ¨åˆ†æ
    {
        "id": "dynamic_character_analysis_map",
        "name": "4. åŠ¨æ€è§’è‰²åˆ†æ (Map)",
        "enabled": true,
        "type": "map",
        "inputListRef": "{{outputs.parse_character_list}}",
        "joinNode": "aggregate_character_actions", // æŒ‡å®šä¸‹ä¸€æ­¥çš„èšåˆèŠ‚ç‚¹
        "templateNode": { // è¿™æ˜¯ä¸ºæ¯ä¸ªè§’è‰²åŠ¨æ€åˆ›å»ºçš„LLMèŠ‚ç‚¹çš„æ¨¡æ¿
            "id": "character_action_template", // ä¸´æ—¶ID
            "name": "è§’è‰²è¡ŒåŠ¨åˆ†ææ¨¡æ¿",
            "type": "llm",
            "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.7 },
            "worldInfo": ["character_info"], // ä½¿ç”¨æ­£ç¡®çš„ä¸–ç•Œä¹¦åç§°ï¼ˆä¸å¸¦.jsonæ‰©å±•åï¼‰
            "promptSlots": [{
                "enabled": true,
                "content": "å½“å‰åœºæ™¯ä¸­æœ‰ä¸€ä½åå« '{{item}}' çš„è§’è‰²ã€‚åŸºäºTAçš„èƒŒæ™¯æ•…äº‹å’Œå½“å‰åœºæ™¯ï¼Œè®¾æƒ³TAæ¥ä¸‹æ¥æœ€å¯èƒ½çš„ä¸€ä¸ªå…·ä½“è¡ŒåŠ¨å’Œä¸€æ®µå†…å¿ƒç‹¬ç™½ã€‚ä»¥ç¬¬ä¸‰äººç§°å°è¯´é£æ ¼è¿›è¡Œæè¿°ã€‚\n\n# è§’è‰² '{{item}}' çš„èƒŒæ™¯\n{{module.worldInfo}}\n\n# å½“å‰åœºæ™¯\n{{outputs.story_generator}}"
            }]
        }
    },

    // èŠ‚ç‚¹ 5: Join/ReduceèŠ‚ç‚¹ - èšåˆæ‰€æœ‰è§’è‰²çš„è¡ŒåŠ¨
    // ã€é‡å¤§æ”¹è¿›ã€‘ä½¿ç”¨æ–°çš„ 'joinFromDynamicNodes' å‡½æ•°
    {
        "id": "aggregate_character_actions",
        "name": "5. èšåˆè§’è‰²è¡ŒåŠ¨",
        "enabled": true,
        "type": "function",
        "functionName": "joinFromDynamicNodes",
        "params": {
            // itemTemplate å®šä¹‰äº†æ¯ä¸ªåŠ¨æ€èŠ‚ç‚¹çš„è¾“å‡ºå¦‚ä½•è¢«æ ¼å¼åŒ–
            "itemTemplate": "å…³äºè§’è‰²â€œ{{item}}â€çš„è¡ŒåŠ¨æ„æƒ³ï¼š\n{{output}}",
            // separator å®šä¹‰äº†å„é¡¹ä¹‹é—´å¦‚ä½•è¿æ¥
            "separator": "\n\n"
        }
    },

    // =================================================================
    // é˜¶æ®µ 3: å‰§æƒ…åˆ†æ”¯ (Router æ¨¡å¼)
    // =================================================================
    
    // èŠ‚ç‚¹ 6: æˆ˜æ–—æ£€æŸ¥LLM
    {
        "id": "combat_check_llm",
        "name": "6. LLMæ£€æŸ¥æˆ˜æ–—å¯èƒ½æ€§",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.0 }, // temperature=0.0 ä½¿è¾“å‡ºæ›´ç¨³å®š
        "promptSlots": [{
            "enabled": true,
            "content": "åˆ†æä»¥ä¸‹åœºæ™¯æè¿°ä¸­æ˜¯å¦éšå«äº†å³å°†å‘ç”Ÿçš„ç‰©ç†å†²çªæˆ–æˆ˜æ–—æ„å›¾ã€‚ä½ çš„å›ç­”åªèƒ½æ˜¯ 'Yes' æˆ– 'No'ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–å­—ç¬¦æˆ–è§£é‡Šã€‚\n\nåœºæ™¯:\n{{outputs.aggregate_character_actions}}"
        }]
    },
    
    // èŠ‚ç‚¹ 7: æˆ˜æ–—å†³ç­–è·¯ç”±å™¨
    // ã€é‡å¤§æ”¹è¿›ã€‘è¿™é‡Œä¸ç›´æ¥ç”¨ combat_check_llm çš„è¾“å‡ºï¼Œè€Œæ˜¯å…ˆé€šè¿‡ä¸€ä¸ªå‡½æ•°èŠ‚ç‚¹è¿”å›å¸ƒå°”å€¼ï¼Œ
    // è¿™æ ·è·¯ç”±å™¨çš„æ¡ä»¶å°±æ˜¯ "true" æˆ– "false"ï¼Œæ›´åŠ ç¨³å¥ã€‚
    // (è™½ç„¶ç›´æ¥åŒ¹é… "Yes" ä¹Ÿå¯ä»¥ï¼Œä½†è¿™æ˜¯ä¸€ä¸ªå±•ç¤ºç»„åˆæ€§çš„å¥½ä¾‹å­)
    {
        "id": "combat_decision_function",
        "name": "7. æˆ˜æ–—å†³ç­–å‡½æ•°",
        "enabled": true,
        "type": "function",
        "functionName": "textContains",
        "params": {
            "sourceNode": "combat_check_llm",
            "keyword": "Yes",
            "caseSensitive": false
        }
    },
    
    // èŠ‚ç‚¹ 8: æˆ˜æ–—è·¯ç”±å™¨
    {
        "id": "combat_router",
        "name": "8. æˆ˜æ–—è·¯ç”±å™¨",
        "enabled": true,
        "type": "router",
        "condition": "{{outputs.combat_decision_function}}", // ä¾èµ–å‡½æ•°èŠ‚ç‚¹çš„å¸ƒå°”è¾“å‡º
        "routes": { 
            "true": "combat_module",    // å¦‚æœæ˜¯ trueï¼Œèµ°å‘æˆ˜æ–—åˆ†æ”¯
            "false": "peaceful_module"  // å¦‚æœæ˜¯ falseï¼Œèµ°å‘å’Œå¹³åˆ†æ”¯
        }
    },

    // èŠ‚ç‚¹ 9a & 9b: å‰§æƒ…åˆ†æ”¯
    {
        "id": "combat_module",
        "name": "9a. æˆ˜æ–—æµç¨‹",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.9 },
        "promptSlots": [{ "enabled": true, "content": "ç»­å†™ä¸‹é¢çš„æ•…äº‹ï¼Œå¼•å…¥ä¸€åœºæ¿€çƒˆçš„æˆ˜æ–—ã€‚è¯¦ç»†æå†™æˆ˜æ–—çš„èµ·å› å’Œæœ€åˆçš„å‡ ä¸ªå›åˆã€‚\n\næ•…äº‹èƒŒæ™¯ï¼š\n{{outputs.aggregate_character_actions}}" }]
    },
    {
        "id": "peaceful_module",
        "name": "9b. å’Œå¹³æµç¨‹",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.6 },
        "promptSlots": [{ "enabled": true, "content": "ç»­å†™ä¸‹é¢çš„æ•…äº‹ï¼Œå±•å¼€ä¸€æ®µå……æ»¡ç´§å¼ æ„Ÿçš„å¯¹è¯æˆ–éæš´åŠ›å†²çªã€‚èšç„¦äºè§’è‰²çš„å¿ƒç†åšå¼ˆå’Œæ½œå°è¯ã€‚\n\næ•…äº‹èƒŒæ™¯ï¼š\n{{outputs.aggregate_character_actions}}" }]
    },

    // =================================================================
    // é˜¶æ®µ 4: æœ€ç»ˆæ•´åˆä¸æ¸…ç†
    // =================================================================

    // èŠ‚ç‚¹ 10: æœ€ç»ˆæ•´åˆå™¨
    {
        "id": "final_formatter",
        "name": "10. æœ€ç»ˆæ•´åˆå™¨",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.5 },
        "promptSlots": [{
            "enabled": true,
            // è¿™ä¸ª prompt ç°åœ¨å¯ä»¥å®‰å…¨åœ°å¤„ç†ç©ºè¾“å…¥äº†ï¼Œå› ä¸º {{outputs.combat_module}} æˆ– {{outputs.peaceful_module}}
            // åœ¨è¢«è·³è¿‡æ—¶ï¼Œæ¨¡æ¿æ¸²æŸ“ä¼šå°†å…¶è§†ä¸ºç©ºå­—ç¬¦ä¸²ã€‚
            "content": "ä½ æ˜¯ä¸€ä½ä¼˜ç§€çš„æ•…äº‹ç¼–è¾‘ã€‚ä½ çš„ä»»åŠ¡æ˜¯ä¼˜åŒ–å’Œå®Œå–„ä¸‹é¢çš„â€œä¸»è¦æ•…äº‹æ–‡æœ¬â€ã€‚\nå¦‚æœä¸‹é¢çš„â€œé™„åŠ ç»­å†™â€éƒ¨åˆ†æœ‰å†…å®¹ï¼Œè¯·å°†å…¶æ— ç¼åœ°èå…¥ä¸»è¦æ•…äº‹æ–‡æœ¬ä¸­ï¼Œå½¢æˆä¸€ä¸ªè¿è´¯ã€æµç•…çš„æ•…äº‹æ®µè½ã€‚å¦‚æœâ€œé™„åŠ ç»­å†™â€éƒ¨åˆ†ä¸ºç©ºï¼Œä½ åªéœ€å¯¹â€œä¸»è¦æ•…äº‹æ–‡æœ¬â€è¿›è¡Œæ¶¦è‰²å’Œç»­å†™ï¼Œç¡®ä¿å®ƒæœ‰ä¸€ä¸ªè‡ªç„¶çš„ç»“å°¾å³å¯ã€‚\nä½ çš„æœ€ç»ˆè¾“å‡ºå¿…é¡»æ˜¯å®Œæ•´çš„æ•…äº‹ï¼Œä¸è¦åŒ…å«ä»»ä½•è§£é‡Šæˆ–æ ‡ç­¾ã€‚\n\n[ä¸»è¦æ•…äº‹æ–‡æœ¬]\n{{outputs.story_generator}}\n\n[é™„åŠ ç»­å†™]\n{{outputs.combat_module}}{{outputs.peaceful_module}}"
        }]
    }
];
```

### data/pluginSetting.js
```
import { defaultPipeline } from './defaultPipeline.js';

export const defaultSettings = {
    isEnabled: true,
    demoString: "This message was intercepted and replaced by the Hevno plugin.",
    pipeline: defaultPipeline, 
    geminiApiKeys: [],
};
```

### scripts/settings/userExtensionSetting.js
```
// src/scripts/settings/userExtensionSetting.js

import { USER } from '../../core/manager.js';
import { apiKeyManager } from '../../core/apiKeyManager.js';

/**
 * éªŒè¯å¯¼å…¥çš„ç®¡çº¿å¯¹è±¡æ˜¯å¦å…·æœ‰åŸºæœ¬ç»“æ„ã€‚
 * @param {any} data - ä»JSONæ–‡ä»¶è§£æå‡ºçš„æ•°æ®ã€‚
 * @returns {boolean} - å¦‚æœæ•°æ®ç»“æ„æœ‰æ•ˆåˆ™è¿”å›trueã€‚
 */
function isValidPipeline(data) {
    if (!Array.isArray(data)) {
        toastr.error("Invalid pipeline: The file content is not an array.", "Import Error");
        return false;
    }
    if (data.length === 0) {
        toastr.warning("Imported pipeline is empty.", "Import Warning");
        return true; // ç©ºç®¡çº¿æ˜¯æœ‰æ•ˆçš„
    }
    const firstModule = data[0];
    if (typeof firstModule !== 'object' || firstModule === null || !('id' in firstModule) || !('name' in firstModule) || !('promptSlots' in firstModule)) {
        toastr.error("Invalid pipeline: Modules are missing required properties (id, name, promptSlots).", "Import Error");
        return false;
    }
    return true;
}

/**
 * ã€æ–°å¢ã€‘å¤„ç†ç®¡çº¿å¯¼å‡ºé€»è¾‘ã€‚
 */
function handleExportPipeline() {
    try {
        const currentPipeline = USER.settings.pipeline;
        const jsonString = JSON.stringify(currentPipeline, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        
        // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ä¸‹è½½é“¾æ¥
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `hevno-pipeline-${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a);
        a.click();
        
        // æ¸…ç†
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        toastr.success("Pipeline exported successfully!", "Export Complete");
    } catch (error) {
        console.error("[Hevno] Failed to export pipeline:", error);
        toastr.error("An error occurred while exporting the pipeline.", "Export Error");
    }
}

/**
 * ã€æ–°å¢ã€‘å¤„ç†æ–‡ä»¶é€‰æ‹©å’Œç®¡çº¿å¯¼å…¥é€»è¾‘ã€‚
 * @param {Event} event - æ–‡ä»¶è¾“å…¥æ¡†çš„changeäº‹ä»¶ã€‚
 */
function handleImportPipeline(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const content = e.target.result;
            const importedPipeline = JSON.parse(content);

            if (isValidPipeline(importedPipeline)) {
                // éªŒè¯é€šè¿‡ï¼Œä¿å­˜åˆ°è®¾ç½®ä¸­
                // USER.settingsçš„Proxyä¼šè‡ªåŠ¨è°ƒç”¨saveSettingsDebounced()
                USER.settings.pipeline = importedPipeline;
                toastr.success("Pipeline imported and saved successfully!", "Import Complete");
            }
        } catch (error) {
            console.error("[Hevno] Failed to import pipeline:", error);
            toastr.error(`Failed to read or parse the pipeline file: ${error.message}`, "Import Error");
        } finally {
            // é‡ç½®æ–‡ä»¶è¾“å…¥æ¡†ï¼Œä»¥ä¾¿å¯ä»¥å†æ¬¡é€‰æ‹©åŒä¸€ä¸ªæ–‡ä»¶
            event.target.value = '';
        }
    };
    reader.onerror = () => {
        toastr.error("Failed to read the selected file.", "File Read Error");
    };

    reader.readAsText(file);
}

/**
 * æ¸²æŸ“è®¾ç½®ç•Œé¢çš„å½“å‰å€¼
 */
export function renderSettings() {
    $('#Hevno_enabled_switch').prop('checked', USER.settings.isEnabled);
    $('#Hevno_demo_string_input').val(USER.settings.demoString);

    const keys = USER.settings.geminiApiKeys || [];
    $('#hevno_gemini_keys_textarea').val(keys.join('\n'));
}

/**
 * ç»‘å®šUIå…ƒç´ çš„äº‹ä»¶ç›‘å¬
 */
function bindEvents() {
    // åŸæœ‰äº‹ä»¶
    $('#Hevno_enabled_switch').on('change', function() {
        USER.settings.isEnabled = $(this).is(':checked');
    });
    $('#Hevno_demo_string_input').on('input', function() {
        USER.settings.demoString = $(this).val();
    });

    // ã€æ–°å¢ã€‘ä¸ºæ–°æŒ‰é’®å’Œæ–‡ä»¶è¾“å…¥æ¡†ç»‘å®šäº‹ä»¶
    $('#hevno_export_pipeline_btn').on('click', handleExportPipeline);
    
    // ç‚¹å‡»â€œå¯¼å…¥â€æŒ‰é’®æ—¶ï¼Œå®é™…è§¦å‘éšè—çš„æ–‡ä»¶è¾“å…¥æ¡†
    $('#hevno_import_pipeline_btn').on('click', () => {
        $('#hevno_pipeline_file_input').click();
    });

    // å½“ç”¨æˆ·é€‰æ‹©äº†æ–‡ä»¶åï¼Œå¤„ç†æ–‡ä»¶å†…å®¹
    $('#hevno_pipeline_file_input').on('change', handleImportPipeline);

        $('#hevno_gemini_keys_textarea').on('input', function() {
        const keysString = $(this).val();
        const keysArray = keysString.split('\n').map(k => k.trim()).filter(k => k);
        USER.settings.geminiApiKeys = keysArray;
        // ç«‹å³é€šçŸ¥å¯†é’¥ç®¡ç†å™¨æ›´æ–°å…¶å¯†é’¥æ± 
        apiKeyManager.loadKeys();
    });
}

/**
 * åŠ è½½è®¾ç½®çš„ä¸»å‡½æ•°
 */
export function loadSettings() {
    renderSettings();
    bindEvents();
    apiKeyManager.loadKeys();
    console.log("[Hevno] Settings UI loaded and pipeline management events bound.");
}
```
