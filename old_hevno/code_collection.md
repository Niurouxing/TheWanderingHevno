### index.js
```
// src/index.js (附有详细注释文档)

/**
 * @file index.js
 * @description 插件的主入口文件。
 * @version 1.1.0
 *
 * @summary
 * 该文件负责插件的初始化，包括：
 * 1.  向SillyTavern页面注入插件的设置UI。
 * 2.  注册核心的生成拦截器 `HevnoInterceptor`，这是插件所有功能的核心。
 *
 * 【新开发者必读】
 * 插件的生命周期从 `jQuery(async () => { ... });` 开始，这确保了代码在页面DOM加载完毕后执行。
 * 核心逻辑位于 `globalThis.HevnoInterceptor` 函数中，请务必理解其工作流程。
 */

import { APP, USER, SYSTEM } from './core/manager.js';
import { loadSettings } from './scripts/settings/userExtensionSetting.js';
import { GenerationOrchestrator } from './core/orchestrator.js';
import { defaultPipeline } from './data/defaultPipeline.js';

console.log("______________________ Hevno Plugin: Loading ______________________");

/**
 * @function HevnoInterceptor
 * @global
 * @description (!!!) 插件的核心 - 生成拦截器。
 *
 * 【关键概念：生成拦截器 (Generation Interceptor)】
 * 这是通过 `manifest.json`中的 `generate_interceptor` 字段注册到SillyTavern的全局函数。
 * 在SillyTavern每次准备向LLM发送请求之前，它会“暂停”并调用这个函数，给予插件干预的机会。
 *
 * 【核心工作流：拦截 -> 执行 -> 喂回】
 * 这个函数的设计遵循了一个健壮的模式，以确保与SillyTavern的深度和安全集成：
 * 1.  **拦截 (Intercept)**: 通过调用 `abort(true)`，我们立即中止SillyTavern的默认生成流程，完全接管控制权。
 * 2.  **执行 (Execute)**: 这是我们插件自定义逻辑的执行阶段。在这里，我们可以进行自己的LLM调用、
 *     数据处理，或者像这个例子一样，简单地准备一个固定的字符串。
 * 3.  **喂回 (Feed-back)**: 我们不直接操作DOM，而是将我们的最终结果通过 `APP.saveReply()` 函数
 *     “喂回”给SillyTavern。SillyTavern会像处理一个真实的AI回复一样，负责后续所有的UI渲染、
 *     事件触发和状态更新。这是最推荐的集成方式。
 * 4.  **清理 (Cleanup)**: 在 `finally` 块中，必须调用 `APP.unblockGeneration()` 来解锁UI，
 *     无论流程成功与否，这都能防止界面卡死。
 *
 * @param {Array} chat - 即将用于构建prompt的聊天历史数组（在此模式下我们通常不直接修改它）。
 * @param {Number} contextSize - 当前的token计数。
 * @param {Function} abort - 中止函数。调用 `abort(true)` 来中止并阻止其他拦截器运行。
 * @param {String} type - 触发生成的类型 (e.g., 'send', 'regenerate', 'swipe')。
 */
globalThis.HevnoInterceptor = async function (chat, contextSize, abort, type) {
    const settings = USER.settings;

    if (!settings.isEnabled) {
        return;
    }

    console.log(`[Hevno] Intercepting generation of type: ${type}`);
    abort(true);

    try {
        console.log("[Hevno] Starting modular generation pipeline...");

        // 【修改】从用户设置中动态获取管线定义
        // USER.settings.pipeline 会自动从SillyTavern的存储中读取，
        // 如果没有，则回退到我们在 pluginSetting.js 中定义的默认值。
        const pipelineDefinition = USER.settings.pipeline;

        if (!pipelineDefinition || !Array.isArray(pipelineDefinition) || pipelineDefinition.length === 0) {
            toastr.error("Hevno pipeline is missing or invalid. Please import a valid pipeline in settings.", "Pipeline Error");
            console.error("[Hevno] No valid pipeline found in settings.");
            return;
        }

        const orchestrator = new GenerationOrchestrator(pipelineDefinition, APP.getContext());

        const finalOutput = await orchestrator.run();

        if (!finalOutput) {
            console.warn("[Hevno] Pipeline ran, but produced no final output.");
            // 即使没有输出，也需要一个空回复来完成流程
            await APP.saveReply({ type: 'normal', getMessage: '' });
        } else {
            await APP.saveReply({
                type: 'normal',
                getMessage: finalOutput,
                title: 'Generated by Hevno Modular Pipeline',
            });
        }

        await APP.saveChatConditional();

        console.log(`[Hevno] Generation completed via modular pipeline.`);

    } catch (error) {
        console.error("[Hevno] An error occurred during the modular pipeline execution:", error);
        toastr.error(`The Hevno Plugin encountered an error: ${error.message}`, "Pipeline Error");
    } finally {
        APP.unblockGeneration(type);
    }
};
/**
 * 插件的主初始化函数。
 * 使用 jQuery(async () => { ... }) 确保在文档对象模型(DOM)完全加载和解析完毕后执行。
 * 这是Web开发的标准实践，可以防止因尝试操作不存在的元素而导致的错误。
 */
jQuery(async () => {
    try {
        const script = document.createElement('script');
        script.type = 'module';
        script.innerHTML = `
            import { GoogleGenerativeAI } from 'https://esm.run/@google/generative-ai';
            window.GoogleGenerativeAI = GoogleGenerativeAI;
        `;
        document.head.appendChild(script);
        console.log('[Hevno] Google Generative AI SDK script injected.');
    } catch (error) {
        console.error('[Hevno] Failed to inject Google AI SDK.', error);
        toastr.error("Failed to load Google AI library. Gemini features will not work.", "Dependency Error");
    }

    // 任务1: 注入插件的设置UI界面。
    try {
        // 使用我们封装的 SYSTEM 管理器来异步加载HTML模板。
        const settingsHtml = await SYSTEM.getTemplate('settings');

        // 使用jQuery将加载的HTML内容附加到SillyTavern的扩展设置面板中。
        // '#extensions_settings' 是SillyTavern中用于放置所有插件设置的容器ID。
        $('#extensions_settings').append(settingsHtml);

        // 加载设置的初始值并为UI元素绑定事件监听器。
        loadSettings();

    } catch (error) {
        console.error("[Hevno] Failed to load settings UI.", error);
    }

    console.log("______________________ Hevno Plugin: Loaded Successfully ______________________");
});
```

### llm_callers/gemini_caller.js
```
// src/llm_callers/gemini_caller.js

import { apiKeyManager } from '../core/apiKeyManager.js';
import { llmLogger } from '../utils/llm_logger.js';

/**
 * 【V4 - 解耦版】执行对Google Gemini API的调用。
 * 自身不包含重试逻辑，完全依赖ApiKeyManager进行密钥轮换。
 * @param {string} prompt - 完整的、渲染后的prompt。
 * @param {object} llmConfig - 来自模块定义的LLM配置。
 * @returns {Promise<string>} LLM生成的文本。
 */
export async function execute(prompt, llmConfig) {
    if (typeof window.GoogleGenerativeAI === 'undefined') {
        throw new Error("Google Generative AI SDK is not loaded.");
    }

    const { model, temperature = 0.7, topP = 1.0, maxOutputTokens = 2048 } = llmConfig;
    let lastError = null;
    let retryAttempt = 0;
    const sessionId = llmLogger.generateSessionId();
    
    const startTime = Date.now();
    console.log(`[LLM-Exec] � Session ${sessionId} | Starting execution...`);
    
    // 循环，直到成功，或ApiKeyManager告知我们已无健康密钥可用
    while (true) {
        retryAttempt++;
        const key = await apiKeyManager.getHealthyKey();

        if (!key) {
            const duration = Date.now() - startTime;
            console.error(`[LLM-Exec] ❌ Session ${sessionId} | No healthy keys available | ${duration}ms`);
            throw lastError || new Error("No healthy API keys available to fulfill the request.");
        }

        try {
            console.log(`[LLM-Exec] 🔑 Session ${sessionId} | Using key ...${key.slice(-4)} | Attempt ${retryAttempt}`);
            
            const genAI = new window.GoogleGenerativeAI(key);
            const generativeModel = genAI.getGenerativeModel({
                model: model,
                generationConfig: { temperature, topP, maxOutputTokens },
            });
            const contents = [{ role: "user", parts: [{ text: prompt }] }];

            const result = await generativeModel.generateContent({ contents });
            const response = await result.response;
            const text = response.text();
            const duration = Date.now() - startTime;
            
            // 解析API响应详情
            const responseData = {
                text: text,
                candidates: response.candidates || [],
                promptFeedback: response.promptFeedback || null,
                usageMetadata: response.usageMetadata || null,
                finishReason: response.candidates?.[0]?.finishReason || 'unknown',
                safetyRatings: response.candidates?.[0]?.safetyRatings || []
            };
            
            // 技术执行层的状态日志
            if (!text || text.trim().length === 0) {
                console.warn(`[LLM-Exec] ⚠️  Session ${sessionId} | EMPTY RESPONSE | ${duration}ms`);
                console.warn(`[LLM-Exec] 🔍 Session ${sessionId} | Candidates: ${responseData.candidates.length} | Finish: ${responseData.finishReason}`);
                
                // 详细的空响应分析
                if (responseData.promptFeedback) {
                    console.warn(`[LLM-Exec] 🛡️  Session ${sessionId} | Prompt blocked:`, responseData.promptFeedback);
                }
                if (responseData.safetyRatings.length > 0) {
                    console.warn(`[LLM-Exec] 🛡️  Session ${sessionId} | Safety ratings:`, responseData.safetyRatings);
                }
                
                // 使用日志工具进行深度分析
                llmLogger.logEmptyResponse(sessionId, prompt, llmConfig, responseData, {
                    apiKey: key,
                    retryAttempt,
                    duration
                });
            } else {
                console.log(`[LLM-Exec] ✅ Session ${sessionId} | Success | ${text.length} chars | ${duration}ms`);
                
                // 记录Token使用情况
                if (responseData.usageMetadata) {
                    const usage = responseData.usageMetadata;
                    console.log(`[LLM-Exec] 📊 Session ${sessionId} | Tokens: ${usage.promptTokenCount}→${usage.candidatesTokenCount} (${usage.totalTokenCount} total)`);
                }
            }

            // 成功！释放key并返回结果
            apiKeyManager.releaseKey(key);
            return text;

        } catch (error) {
            lastError = error;
            const duration = Date.now() - startTime;
            
            console.error(`[LLM-Exec] ❌ Session ${sessionId} | Key ...${key.slice(-4)} failed | ${duration}ms`);
            console.error(`[LLM-Exec] 🔍 Session ${sessionId} | Error: ${error.name} - ${error.message}`);
            
            // 使用分析工具进行错误分析
            if (retryAttempt === 1) { // 只在第一次失败时详细分析
                llmLogger.analyzeError(error, { apiKey: key, sessionId });
            }
            
            await apiKeyManager.recordFailure(key, error);
        }
    }
}
```

### core/llm_dispatcher.js
```
// src/core/llm_dispatcher.js

import * as geminiCaller from '../llm_callers/gemini_caller.js';
// 未来可以在这里添加更多caller:
// import * as openaiCaller from '../llm_callers/openai_caller.js';

const providers = {
    'gemini': geminiCaller,
    // 'openai': openaiCaller,
};

/**
 * 根据llmConfig中的provider，将请求分派给正确的LLM调用者。
 * @param {string} prompt - 渲染后的prompt。
 * @param {object} llmConfig - 模块的LLM配置。
 * @returns {Promise<string>} 来自LLM的响应。
 */
export async function dispatch(prompt, llmConfig) {
    const providerName = llmConfig.provider;
    if (!providerName) {
        throw new Error("Module is missing 'provider' field in its 'llm' configuration.");
    }

    const caller = providers[providerName.toLowerCase()];
    if (!caller) {
        throw new Error(`Unsupported LLM provider: "${providerName}". No caller found.`);
    }

    // 简洁的调度日志
    console.log(`[LLM-Dispatch] 🚀 Routing to ${providerName}/${llmConfig.model || 'default'}`);

    try {
        const result = await caller.execute(prompt, llmConfig);
        console.log(`[LLM-Dispatch] ✅ ${providerName} completed successfully`);
        return result;
    } catch (error) {
        console.error(`[LLM-Dispatch] ❌ ${providerName} failed: ${error.message}`);
        throw error;
    }
}
```

### core/manager.js
```
// src/core/manager.js

/**
 * @file manager.js
 * @description 插件的核心管理器和API抽象层。
 */

// I. 导入SillyTavern的核心功能
import {
    eventSource,
    event_types,
    saveSettingsDebounced,
    saveReply,
    saveChatConditional,
    activateSendButtons,
    addOneMessage,
    deleteLastMessage,
    generateRaw,
    reloadCurrentChat,
    sendSystemMessage,
    substituteParams,
} from '/script.js';
import { getTokenCountAsync } from '/scripts/tokenizers.js';
import { getContext, extension_settings, renderExtensionTemplateAsync } from '/scripts/extensions.js';
import { Popup, POPUP_TYPE, callGenericPopup } from '/scripts/popup.js';

// 【修改】导入正确的、高层的API和可写变量
import {
    getWorldInfoPrompt,
    selected_world_info,
    loadWorldInfo,
    world_names,
    world_info, // 添加这个导入来访问世界书数据
} from '/scripts/world-info.js';

import { defaultSettings } from '../data/pluginSetting.js';

// II. 定义和导出管理器

/**
 * @namespace APP
 * @description 应用管理器 (APP)
 */
export const APP = {
    getContext,
    eventSource,
    event_types,
    saveReply,
    unblockGeneration: activateSendButtons,
    generateRaw,
    addOneMessage,
    sendSystemMessage,
    deleteLastMessage,
    reloadCurrentChat,
    saveChatConditional,
    renderExtensionTemplateAsync,
    substituteParams,
    getTokenCountAsync,
};

/**
 * @namespace USER
 * @description 用户数据管理器 (USER)
 */
export const USER = {
    settings: new Proxy({}, {
        get(_, property) {
            const settings = extension_settings.Hevno_settings;
            if (settings && property in settings) {
                return settings[property];
            }
            return defaultSettings[property];
        },
        set(_, property, value) {
            if (!extension_settings.Hevno_settings) {
                extension_settings.Hevno_settings = {};
            }
            extension_settings.Hevno_settings[property] = value;
            saveSettingsDebounced();
            return true;
        },
    }),
    saveSettings: saveSettingsDebounced,
};

/**
 * @namespace EDITOR
 * @description 编辑器/UI管理器 (EDITOR)
 */
export const EDITOR = {
    Popup,
    POPUP_TYPE,
    callGenericPopup,
};

/**
 * @namespace SYSTEM
 * @description 系统工具管理器 (SYSTEM)
 */
export const SYSTEM = {
    getTemplate: (name) => {
        return APP.renderExtensionTemplateAsync('third-party/Hevno/assets/templates', name);
    },

    /**
     * 【最终版】封装 SillyTavern 的顶层 World Info 获取函数。
     * @param {Array<string>} chat - 聊天消息文本数组
     * @param {number} maxContext - 最大上下文大小
     * @param {boolean} isDryRun - 是否为演练模式
     * @param {object} globalScanData - 角色、场景等附加扫描数据
     * @returns {Promise<object>} 返回一个包含 .worldInfoString 的对象
     */
    getWorldInfoPrompt: getWorldInfoPrompt,

    /**
     * 获取当前全局选择的世界书列表。
     * @returns {Array<string>}
     */
    getSelectedWorldInfo: () => [...selected_world_info],

    /**
     * 临时设置SillyTavern全局选择的世界书列表。
     * @param {Array<string>} worlds - 世界书文件名列表。
     */
    setSelectedWorldInfo: (worlds) => {
        selected_world_info.length = 0;
        selected_world_info.push(...worlds);
    },

    /**
     * 【新增】直接暴露SillyTavern的WI文件加载函数。
     * @param {string} worldName - 要加载的世界书文件名。
     * @returns {Promise<object|null>} 加载的数据或null。
     */
    loadWorldInfo: loadWorldInfo,

    /**
     * 【新增】清理世界书缓存和状态
     */
    clearWorldInfoCache: () => {
        try {
            // 清理world_info中的所有条目
            if (world_info && typeof world_info === 'object') {
                Object.keys(world_info).forEach(key => {
                    delete world_info[key];
                });
            }
            console.log('[SYSTEM] World info cache cleared');
        } catch (error) {
            console.warn('[SYSTEM] Failed to clear world info cache:', error);
        }
    },

    /**
     * 【新增】卸载所有已加载的世界书（但保留选择列表）
     */
    unloadAllWorldInfo: async () => {
        try {
            // 【修复】只清理世界书数据缓存，不清理选择列表
            // 这样loadWorldInfo可以重新加载，但selected_world_info保持正确状态
            if (world_info && typeof world_info === 'object') {
                Object.keys(world_info).forEach(key => {
                    delete world_info[key];
                });
            }
            
            console.log('[SYSTEM] World info data cleared (keeping selection)');
        } catch (error) {
            console.warn('[SYSTEM] Failed to unload world info:', error);
        }
    },


    /**
     * 【新增】获取所有已知的世界书文件名。
     * @returns {Array<string>}
     */
    getWorldNames: () => [...world_names],


    /**
     * 【新增】临时设置所有已知的世界书文件名。
     * @param {Array<string>} newWorldNames - 新的世界书文件名列表。
     */
    setWorldNames: (newWorldNames) => {
        world_names.length = 0; // Clear the array
        Array.prototype.push.apply(world_names, newWorldNames); // Mutate it
    },

    /**
     * 获取角色数据
     * @returns {Array}
     */
    getCharacters: () => getContext()?.characters || [],

    /**
     * 获取当前角色ID
     * @returns {number}
     */
    getCurrentCharacterId: () => getContext()?.characterId || -1,

    /**
     * 获取聊天元数据
     * @returns {object}
     */
    getChatMetadata: () => getContext()?.chat_metadata || {},

    /**
     * 设置聊天元数据
     * @param {string} key
     * @param {any} value
     */
    setChatMetadata: (key, value) => {
        const context = getContext();
        if (context?.chat_metadata) {
            context.chat_metadata[key] = value;
        }
    },

    /**
     * 获取power_user对象
     * @returns {object}
     */
    getPowerUser: () => getContext()?.power_user || {},

    /**
     * METADATA_KEY常量
     */
    METADATA_KEY: 'world_info',

    /**
     * 获取世界书数据对象
     * @returns {object}
     */
    getWorldInfoData: () => world_info,
};
```

### core/function_registry.js
```
// src/core/function_registry.js

import { USER } from './manager.js';

/**
 * @file function_registry.js
 * @description 存放所有可被FunctionNode调用的自定义JS函数。
 * 
 * 【设计哲学 V2 - 通用性与可组合性】
 * 1.  **单一职责**: 每个函数只做一件小事，并把它做好。例如，不将“检查文本”和“决定是否战斗”混为一谈。
 * 2.  **通用性**: 函数名应描述其通用行为，而不是某个特定的业务场景。例如，`textContains` 而不是 `isCombatRequired`。
 * 3.  **参数化**: 将硬编码的值（如 "yes", "<thinking>") 提取为参数，让用户在 Pipeline 定义中指定它们。
 * 4.  **上下文作为输入**: 每个函数都接收完整的编排器上下文(context)和节点参数(params)。
 * 5.  **可预测的输出**: 函数的返回值应该是简单、可预测的数据类型（字符串、数组、布尔值），以便于下游节点消费。
 */
export const functionRegistry = {
    // =================================================================
    // 文本处理工具 (Text Processing Utilities)
    // =================================================================

    /**
     * 【新】检查输入文本是否包含指定的关键字。
     * 这是 isCombatRequired 的通用替代品。
     * @param {object} context 
     * @param {object} params - { sourceNode: string, keyword: string, caseSensitive: boolean (default: false) }
     * @returns {boolean} 如果找到关键字，则返回 true，否则返回 false。
     */
    textContains: (context, params) => {
        const { sourceNode, keyword, caseSensitive = false } = params;
        if (!keyword) throw new Error("[textContains] 'keyword' parameter is required.");
        
        const rawOutput = context.outputs[sourceNode];
        if (typeof rawOutput !== 'string') return false;

        if (caseSensitive) {
            return rawOutput.includes(keyword);
        } else {
            return rawOutput.toLowerCase().includes(keyword.toLowerCase());
        }
    },

    /**
     * 【新】使用正则表达式替换文本内容。
     * 这是 stripLlmThinking 的通用替代品。
     * @param {object} context 
     * @param {object} params - { sourceNode: string, pattern: string, flags: string (default: 'g'), replacement: string (default: '') }
     * @returns {string} 处理后的字符串。
     */
    regexReplace: (context, params) => {
        const { sourceNode, pattern, flags = 'g', replacement = '' } = params;
        if (!pattern) throw new Error("[regexReplace] 'pattern' parameter is required.");

        const rawOutput = context.outputs[sourceNode];
        if (typeof rawOutput !== 'string') return '';

        try {
            const regex = new RegExp(pattern, flags);
            return rawOutput.replace(regex, replacement);
        } catch (e) {
            throw new Error(`[regexReplace] Invalid regex pattern: ${e.message}`);
        }
    },

    /**
     * 【新】使用正则表达式从文本中提取所有匹配项的特定捕获组。
     * 这是一个更底层的工具，可用于实现像 parseCharacterList 这样的功能。
     * @param {object} context 
     * @param {object} params - { sourceNode: string, pattern: string, flags: string (default: 'g'), groupIndex: number (default: 1) }
     * @returns {string[]} 包含所有匹配的捕获组文本的数组。
     */
    extractWithRegex: (context, params) => {
        const { sourceNode, pattern, flags = 'g', groupIndex = 1 } = params;
        if (!pattern) throw new Error("[extractWithRegex] 'pattern' parameter is required.");

        const rawOutput = context.outputs[sourceNode];
        if (typeof rawOutput !== 'string') return [];

        try {
            const regex = new RegExp(pattern, flags);
            const matches = [...rawOutput.matchAll(regex)];
            return matches.map(match => match[groupIndex] || '').filter(Boolean);
        } catch (e) {
            throw new Error(`[extractWithRegex] Invalid regex pattern: ${e.message}`);
        }
    },

    // =================================================================
    // 结构化数据处理 (Structured Data Processing)
    // =================================================================

    /**
     * 【保留并改进】这是一个高级便利函数，用于从特定格式的文本中解析角色列表。
     * 它内部使用了更通用的逻辑，但为常见任务提供了便利。
     * @param {object} context
     * @param {object} params - { sourceNode: string }
     * @returns {string[]} 解析出的角色名称数组。
     */
    parseCharacterList: (context, params) => {
        const rawOutput = context.outputs[params.sourceNode];
        if (!rawOutput) return [];
        
        const lowerCaseOutput = rawOutput.toLowerCase();
        
        // 检查是否明确指出没有角色
        if (lowerCaseOutput.includes('characters: none') || lowerCaseOutput.includes('characters:none')) {
            return [];
        }

        const matches = rawOutput.match(/Characters:(.*)/i);
        if (matches && matches[1]) {
            const characterString = matches[1].trim();
            if (characterString.toLowerCase() === 'none' || characterString === '') {
                return [];
            }
            return characterString.split(',').map(name => name.trim()).filter(Boolean);
        }
        return [];
    },

    /**
     * 【新】聚合来自 Map 节点的动态输出。
     * 这是 aggregateStoryParts 的通用、可配置的替代品。
     * @param {object} context
     * @param {object} params - { 
     *   sourceNodeIds: string[], 
     *   itemTemplate: string (e.g., "Action for {{item}}: {{output}}"), 
     *   separator: string (default: '\n\n') 
     * }
     * @returns {string} 拼接后的字符串。
     */
    joinFromDynamicNodes: (context, params) => {
        const { sourceNodeIds, itemTemplate, separator = '\n\n' } = params;
        if (!sourceNodeIds || !Array.isArray(sourceNodeIds)) return "";
        if (!itemTemplate) throw new Error("[joinFromDynamicNodes] 'itemTemplate' parameter is required.");
        
        const parts = sourceNodeIds.map(nodeId => {
            const output = context.outputs[nodeId] || '';
            const dynamicNodeDef = context.nodes[nodeId];
            const item = dynamicNodeDef?.injectedParams?.item || 'Unknown';
            
            return itemTemplate
                .replace(/{{output}}/g, output)
                .replace(/{{item}}/g, item);
        });
        
        return parts.join(separator);
    },

    // =================================================================
    // 验证与逻辑 (Validation & Logic)
    // =================================================================

    /**
     * 【新】验证输入文本的最小长度。
     * 可用于构建重试循环。
     * @param {object} context
     * @param {object} params - { sourceNode: string, minLength: number }
     * @returns {boolean} 如果文本长度大于等于 minLength，则返回 true。
     */
    validateMinLength: (context, params) => {
        const { sourceNode, minLength = 1 } = params;
        const rawOutput = context.outputs[sourceNode];
        if (typeof rawOutput !== 'string') return false;

        return rawOutput.trim().length >= minLength;
    }
};

/**
 * 安全地执行注册表中的函数。
 * @param {string} functionName - 要执行的函数名。
 * @param {object} context - 编排器上下文。
 * @param {object} params - 节点定义中的参数。
 * @returns {any} 函数的返回值。
 */
export function executeFunction(functionName, context, params) {
    if (typeof functionRegistry[functionName] !== 'function') {
        throw new Error(`Function "${functionName}" is not defined in the function registry.`);
    }
    return functionRegistry[functionName](context, params);
}
```

### core/apiKeyManager.js
```
// src/core/apiKeyManager.js

import { USER } from './manager.js';
import { renderSettings } from '../scripts/settings/userExtensionSetting.js';

// --- Key Status Enums ---
const KEY_STATUS = {
    HEALTHY: 'healthy',
    BANNED: 'banned',
    SUSPENDED: 'suspended'
};

const QUOTA_ERROR_LIMIT_PER_DAY = 5;

// --- 错误分类函数 ---
function getErrorType(error) {
    const message = error.message.toLowerCase();
    const status = error.message.match(/\[(\d{3})\]/)?.[1] || '';

    if (message.includes('api key not valid') || 
        message.includes('permission denied') || 
        message.includes('consumer suspended') ||
        message.includes('expired') ||
        (status === '403') ||
        (status === '400') // 将400作为API Key错误的强信号，因为它通常与请求格式或认证有关
    ) {
        return 'ApiKeyError';
    }
    if (status === '429' || message.includes('quota exceeded') || message.includes('rate limit exceeded')) {
        return 'QuotaError';
    }
    // [!code focus:start]
    // --- 新增：识别自定义的空响应错误 ---
    if (message.includes('emptyresponseerror') || status.startsWith('5') || message.includes('socket hang up') || message.includes('fetch failed')|| message.includes('prohibited')) {
        return 'NetworkError'; // 将空响应归类为网络/瞬时错误
    }
    // [!code focus:end]
    return 'UnknownError';
}

// ... ApiKeyManager 类的其余部分保持不变 ...
class ApiKeyManager {
    constructor() {
        this.keyPool = new Map(); // key -> { status: string, stats: object }
        this.busyKeys = new Set();
        this.waitQueue = [];
    }

    /**
     * 从用户设置加载或刷新API密钥池。
     */
    loadKeys() {
        const userKeys = USER.settings.geminiApiKeys || [];
        const today = new Date().toISOString().slice(0, 10);

        // 清理旧的key，保留已有的健康数据
        const newKeySet = new Set(userKeys);
        for (const key of this.keyPool.keys()) {
            if (!newKeySet.has(key)) {
                this.keyPool.delete(key);
            }
        }
        
        // 添加新key或更新现有key的状态
        userKeys.forEach(key => {
            if (key && key.trim() !== '') {
                if (!this.keyPool.has(key)) {
                    this.keyPool.set(key, {
                        status: KEY_STATUS.HEALTHY,
                        stats: {
                            lastErrorDate: '',
                            quotaErrorCount: 0,
                            networkErrorCount: 0,
                            suspensionEndTime: 0
                        }
                    });
                } else {
                    // 如果是新的一天，重置每日配额计数
                    const entry = this.keyPool.get(key);
                    if (entry.stats.lastErrorDate !== today) {
                        entry.stats.quotaErrorCount = 0;
                    }
                    // 如果停用时间已过，恢复健康状态
                    if (entry.status === KEY_STATUS.SUSPENDED && Date.now() > entry.stats.suspensionEndTime) {
                        entry.status = KEY_STATUS.HEALTHY;
                        entry.stats.suspensionEndTime = 0;
                        console.log(`[ApiKeyManager] Key ...${key.slice(-4)} has been restored from suspension.`);
                    }
                }
            }
        });

        console.log(`[ApiKeyManager] Loaded and synchronized ${this.keyPool.size} keys.`);
        this._processWaitQueue();
    }

    /**
     * 获取一个健康的、空闲的API密钥。
     * @returns {Promise<string|null>} 一个解析为可用密钥或null的Promise。
     */
    getHealthyKey() {
        // 每次获取时都刷新状态，确保及时恢复被暂停的key
        this.loadKeys(); 

        const healthyAndFreeKeys = Array.from(this.keyPool.entries())
            .filter(([key, data]) => 
                data.status === KEY_STATUS.HEALTHY && !this.busyKeys.has(key)
            );

        if (healthyAndFreeKeys.length > 0) {
            const [keyToUse] = healthyAndFreeKeys[0]; 
            this.busyKeys.add(keyToUse);
            console.log(`[ApiKeyManager] Acquired healthy key ...${keyToUse.slice(-4)}`);
            return Promise.resolve(keyToUse);
        }
        
        const healthyButBusy = Array.from(this.keyPool.entries())
            .some(([key, data]) => data.status === KEY_STATUS.HEALTHY && this.busyKeys.has(key));
            
        if (healthyButBusy) {
             console.log(`[ApiKeyManager] All healthy keys are busy. Request is now waiting.`);
             return new Promise(resolve => this.waitQueue.push(resolve));
        }

        return Promise.resolve(null);
    }

    /**
     * 报告一次失败，管理器将据此更新密钥状态。
     * @param {string} key - 失败的密钥。
     * @param {Error} error - 捕获到的错误对象。
     */
    async recordFailure(key, error) {
        if (!this.keyPool.has(key)) return;

        const entry = this.keyPool.get(key);
        const errorType = getErrorType(error);
        const today = new Date().toISOString().slice(0, 10);
        entry.stats.lastErrorDate = today;

        console.warn(`[ApiKeyManager] Failure recorded for key ...${key.slice(-4)}. Type: ${errorType}. Error: ${error.message}`);

        switch (errorType) {
            case 'ApiKeyError':
                entry.status = KEY_STATUS.BANNED;
                console.error(`[ApiKeyManager] Key ...${key.slice(-4)} has been permanently banned.`);
                toastr.error(`An API key (...${key.slice(-4)}) was found to be invalid/banned and has been permanently disabled.`, "API Key Banned");
                
                // [!code focus:start]
                // 【关键修正】我们应该直接在这里修改用户设置，而不是依赖下次loadKeys
                const currentKeys = USER.settings.geminiApiKeys || [];
                // 过滤掉当前坏掉的key
                const newKeys = currentKeys.filter(k => k !== key);
                // 确保 USER.settings.geminiApiKeys 被正确赋值以触发代理的set
                if (newKeys.length !== currentKeys.length) {
                    USER.settings.geminiApiKeys = newKeys;
                }

            case 'QuotaError':
                entry.stats.quotaErrorCount++;
                if (entry.stats.quotaErrorCount >= QUOTA_ERROR_LIMIT_PER_DAY) {
                    entry.status = KEY_STATUS.SUSPENDED;
                    const tomorrow = new Date();
                    tomorrow.setHours(24, 0, 0, 0); 
                    entry.stats.suspensionEndTime = tomorrow.getTime();
                    console.error(`[ApiKeyManager] Key ...${key.slice(-4)} has reached its daily quota limit and is suspended until tomorrow.`);
                    toastr.warning(`An API key (...${key.slice(-4)}) seems to have hit its daily limit. It will be temporarily disabled.`, "Key Suspended");
                }
                break;
                
            case 'NetworkError':
                entry.stats.networkErrorCount++;
                break;
        }
        
        this.releaseKey(key);
    }
    
    releaseKey(key) {
        if (key && this.busyKeys.has(key)) {
            this.busyKeys.delete(key);
            console.log(`[ApiKeyManager] Released key ...${key.slice(-4)}.`);
            this._processWaitQueue();
        }
    }

    _processWaitQueue() {
        if (this.waitQueue.length > 0) {
            const healthyAndFreeKeys = Array.from(this.keyPool.entries())
                .filter(([key, data]) => 
                    data.status === KEY_STATUS.HEALTHY && !this.busyKeys.has(key)
                );
            if (healthyAndFreeKeys.length > 0) {
                const [keyToUse] = healthyAndFreeKeys[0];
                const nextInQueue = this.waitQueue.shift();
                this.busyKeys.add(keyToUse);
                console.log(`[ApiKeyManager] Re-assigned key ...${keyToUse.slice(-4)} to waiting request.`);
                nextInQueue(keyToUse);
            }
        }
    }
}

export const apiKeyManager = new ApiKeyManager();
```

### core/orchestrator.js
```
// src/core/orchestrator.js

import { dispatch as dispatchLLM } from './llm_dispatcher.js';
import { executeFunction } from './function_registry.js';
import { APP, SYSTEM } from './manager.js';

/**
 * @class GenerationOrchestrator
 * @description 模块化生成流程的编排与执行引擎（V2 - 支持动态图）。
 */
export class GenerationOrchestrator {
    // ... constructor 和其他辅助函数 (_formatChatHistory, _resolvePath, etc.) 保持不变 ...
    constructor(pipelineDefinition, initialSillyTavernContext) {
        this.initialPipeline = pipelineDefinition;
        this.rawContext = initialSillyTavernContext;

        // 运行时的状态
        this.nodes = {}; // 存储所有节点定义，包括动态生成的
        this.nodeStates = {}; // 'pending', 'running', 'completed', 'failed', 'skipped'
        this.dependencies = new Map(); // node_id -> Set<dependency_id>
        this.dependents = new Map(); // node_id -> Set<dependent_id>

        // 【新增】世界书访问互斥锁
        this.worldInfoMutex = Promise.resolve();

        this.context = {
            sillyTavern: {
                character: this.rawContext.characters[this.rawContext.characterId],
                userInput: this.rawContext.chat.slice(-1)[0]?.mes || '',
                userName: this.rawContext.name1,
                chat: this.rawContext.chat,
            },
            outputs: {}, // 所有节点的输出都存在这里
            nodes: this.nodes, // 让FunctionNode可以访问节点定义
            module: {}, // 旧的模块上下文，保持兼容性
        };

        this.finalOutputNodeId = 'final_formatter'; // 可以从管线元数据中读取
    }

    _formatChatHistory(chatArray) {
        if (!Array.isArray(chatArray)) return '';
        return chatArray.map(message => {
            const prefix = message.is_user ? (this.context.sillyTavern.userName || 'User') : (this.context.sillyTavern.character?.name || 'Assistant');
            return `${prefix}: ${message.mes}`;
        }).join('\n');
    }

    _resolvePath(path, contextObject) {
        // 允许注入动态参数，例如来自MapNode
        if (path.startsWith('item')) {
            const dynamicValue = path.split('.').reduce((acc, part) => (acc ? acc[part] : undefined), contextObject);
            if (dynamicValue !== undefined) return dynamicValue;
        }

        let current = contextObject;
        const parts = path.split('.');
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (current && typeof current === 'object' && part in current) {
                current = current[part];
            } else {
                // [!code focus:start]
                // 【已修正】只在路径不是一个可选的 'outputs' 时才发出警告。
                // 这是为了避免在处理由路由器跳过的节点的输出时产生不必要的控制台噪音。
                if (!path.startsWith('outputs.')) {
                    console.warn(`[Orchestrator] Path resolution failed. Key "${part}" not found in context for path "${path}".`);
                }
                // [!code focus:end]
                return undefined;
            }
        }
        return current;
    }



    async _calculateModuleWorldInfo(module) {
        // 步骤 1: 如果节点没有配置World Info，直接返回一个解析为空字符串的Promise。
        if (!module.worldInfo || !Array.isArray(module.worldInfo) || module.worldInfo.length === 0) {
            return Promise.resolve('');
        }

        // 步骤 2: 检查必要的SillyTavern函数是否存在。
        if (typeof SYSTEM.getWorldInfoPrompt !== 'function' || typeof SYSTEM.loadWorldInfo !== 'function') {
            console.error('[Orchestrator] World Info functions are not available in the SYSTEM manager.');
            return Promise.resolve('');
        }

        // 步骤 3: 【健壮的互斥锁】创建一个新的Promise任务，并将其链接到当前的互斥锁Promise链上。
        // 这确保了无论多少个节点并发调用此函数，它们都会被排队，一次只执行一个任务。
        const taskPromise = this.worldInfoMutex.then(async () => {
            // --- 从这里开始，是受锁保护的临界区 ---

            console.log(`[Orchestrator] [LOCK ACQUIRED] Preparing isolated WI environment for node: ${module.id}. Books: [${module.worldInfo.join(', ')}]`);

            // 步骤 4: 【备份】保存SillyTavern当前的全局WI状态。
            const originalState = {
                selected_world_info: SYSTEM.getSelectedWorldInfo(),
                chat_lorebook: SYSTEM.getChatMetadata()?.[SYSTEM.METADATA_KEY],
                // 注意：这里可以根据需要备份更多与WI相关的状态。
            };

            let worldInfoString = '';

            try {
                // 步骤 5: 【清理】创建一个干净的环境，为当前节点准备舞台。
                SYSTEM.setSelectedWorldInfo([]);
                SYSTEM.setChatMetadata(SYSTEM.METADATA_KEY, undefined);
                if (typeof SYSTEM.unloadAllWorldInfo === 'function') {
                    await SYSTEM.unloadAllWorldInfo();
                }

                // 步骤 6: 【加载】只加载当前节点定义中明确要求的世界书。
                SYSTEM.setSelectedWorldInfo(module.worldInfo);
                for (const worldName of module.worldInfo) {
                    try {
                        await SYSTEM.loadWorldInfo(worldName);
                    } catch (error) {
                        console.warn(`[Orchestrator] Failed to load world info "${worldName}" for node ${module.id}:`, error);
                    }
                }
                
                // 等待一个事件循环，确保DOM和内部状态更新生效。
                await new Promise(resolve => setTimeout(resolve, 10));

                // 步骤 7: 【执行】在隔离环境中计算WI。
                const chatMessages = this.rawContext.chat.map(m => m.mes);
                const maxContextSize = this.rawContext.max_context || 4096;
                const globalScanData = {
                    personaDescription: this.rawContext.persona?.description ?? '',
                    characterDescription: this.context.sillyTavern.character?.description ?? '',
                    characterPersonality: this.context.sillyTavern.character?.personality ?? '',
                    scenario: this.rawContext.scenario ?? '',
                    userInput: this.context.sillyTavern.userInput ?? '',
                };

                const wiResult = await SYSTEM.getWorldInfoPrompt(chatMessages, maxContextSize, true, globalScanData);
                worldInfoString = (wiResult?.worldInfoString || '').trim();

                if (worldInfoString) {
                    console.log(`[Orchestrator] Node ${module.id} generated ${worldInfoString.length} chars of WI.`);
                } else {
                    console.warn(`[Orchestrator] Node ${module.id} generated no WI with books [${module.worldInfo.join(', ')}]`);
                }

            } catch (error) {
                console.error(`[Orchestrator] An error occurred during isolated WI calculation for node ${module.id}:`, error);
                worldInfoString = ''; // 确保出错时返回空字符串
            } finally {
                // 步骤 8: 【恢复】无论成功与否，都必须恢复SillyTavern的原始状态，清理舞台。
                console.log(`[Orchestrator] [LOCK RELEASED] Restoring original WI state after processing node ${module.id}.`);
                SYSTEM.setSelectedWorldInfo(originalState.selected_world_info);
                if (originalState.chat_lorebook !== undefined) {
                    SYSTEM.setChatMetadata(SYSTEM.METADATA_KEY, originalState.chat_lorebook);
                }
                // --- 临界区结束 ---
            }
            
            return worldInfoString;
        });

        // 步骤 9: 更新互斥锁，使其指向我们刚刚创建的新任务Promise。
        // 这样，下一个调用者就必须等待这个任务完成。
        this.worldInfoMutex = taskPromise;

        // 步骤 10: 返回这个任务Promise。
        // `_executeLLMNode` 将会 `await` 这个Promise，从而等待WI计算的完成。
        return taskPromise;
    }

    _renderPrompt(node, injectedParams = {}) {
        let fullPrompt = '';
        const renderContext = { ...this.context, ...injectedParams };
        for (const slot of node.promptSlots) {
            if (slot.enabled) {
                const renderedContent = slot.content.replace(/{{(.*?)}}/g, (match, path) => {
                    const value = this._resolvePath(path.trim(), renderContext);
                    // [!code focus:start]
                    // 【已修正】如果路径解析结果为 undefined 或 null，则将其视为空字符串。
                    // 这对于处理可选的、被跳过的分支节点的输出至关重要。
                    if (value === undefined || value === null) {
                        return ''; // 返回空字符串，而不是保留占位符
                    }
                    // [!code focus:end]
                    if (path.trim() === 'sillyTavern.chat') return this._formatChatHistory(value);
                    if (typeof value === 'object') return JSON.stringify(value, null, 2);
                    return String(value);
                });
                fullPrompt += renderedContent + '\n';
            }
        }
        return fullPrompt.trim();
    }

    // [!code focus:99]
    // =================================================================
    // NEW DYNAMIC EXECUTION LOGIC
    // =================================================================

    // [!code focus:start]
    /**
     * 【已修正】构建完整的依赖图。
     * 此版本会检查所有可能定义依赖关系的地方。
     */
    _initializeGraph() {
        // 清理旧状态
        Object.keys(this.nodes).forEach(key => delete this.nodes[key]);
        this.nodeStates = {};
        this.dependencies.clear();
        this.dependents.clear();

        // 步骤 1: 加载所有节点的基本信息
        for (const nodeDef of this.initialPipeline) {
            if (nodeDef.enabled) {
                this.nodes[nodeDef.id] = JSON.parse(JSON.stringify(nodeDef));
                this.nodeStates[nodeDef.id] = 'pending';
                this.dependencies.set(nodeDef.id, new Set());
                this.dependents.set(nodeDef.id, new Set());
            }
        }

        // 步骤 2: 遍历所有节点，为它们添加依赖
        const dependencyRegex = /{{\s*outputs\.([\w.-]+)\s*}}/g;

        for (const nodeId in this.nodes) {
            const node = this.nodes[nodeId];
            const nodeDependencies = this.dependencies.get(nodeId);

            // a. 从模板/prompt中提取 '{{outputs...}}' 依赖
            const contentToCheck = JSON.stringify(node.promptSlots || '');
            for (const match of contentToCheck.matchAll(dependencyRegex)) {
                if (this.nodes[match[1]]) {
                    nodeDependencies.add(match[1]);
                }
            }

            // b. 【新增】检查特定节点类型的参数依赖
            const params = node.params || {};
            if (params.sourceNode && this.nodes[params.sourceNode]) {
                nodeDependencies.add(params.sourceNode);
            }
            if (params.sourceNodeIds && Array.isArray(params.sourceNodeIds)) {
                params.sourceNodeIds.forEach(id => {
                    if (this.nodes[id]) nodeDependencies.add(id);
                });
            }

            // c. 【新增】检查MapNode和Router的特定依赖
            if (node.type === 'map' && node.inputListRef) {
                const listSourceMatch = node.inputListRef.match(/outputs\.([\w.-]+)/);
                if (listSourceMatch && this.nodes[listSourceMatch[1]]) {
                    nodeDependencies.add(listSourceMatch[1]);
                }
            }
            if (node.type === 'router' && node.condition) {
                const conditionMatch = node.condition.match(/outputs\.([\w.-]+)/);
                if (conditionMatch && this.nodes[conditionMatch[1]]) {
                    nodeDependencies.add(conditionMatch[1]);
                }
            }
        }

        // 步骤 3: 专门处理结构性依赖（在所有其他依赖建立之后）
        for (const nodeId in this.nodes) {
            const node = this.nodes[nodeId];

            // a. JoinNode 依赖于 MapNode
            if (node.type === 'map' && node.joinNode) {
                const joinNodeId = node.joinNode;
                if (this.dependencies.has(joinNodeId)) {
                    this.dependencies.get(joinNodeId).add(nodeId);
                }
            }

            // b. 路由器的分支目标依赖于路由器本身
            if (node.type === 'router' && node.routes) {
                for (const routeKey in node.routes) {
                    const targetNodeId = node.routes[routeKey];
                    if (this.dependencies.has(targetNodeId)) {
                        this.dependencies.get(targetNodeId).add(nodeId);
                    }
                }
            }
        }
        // [!code focus:end]

        // 步骤 4: 构建反向依赖图 (dependents)
        for (const [nodeId, deps] of this.dependencies.entries()) {
            for (const depId of deps) {
                if (this.dependents.has(depId)) {
                    this.dependents.get(depId).add(nodeId);
                }
            }
        }

        console.log('[GraphInit] Dependency graph constructed:', this.dependencies);
    }

    async _executeNode(nodeId) {
        const node = this.nodes[nodeId];
        if (!node) {
            throw new Error(`Node with ID "${nodeId}" not found.`);
        }

        console.log(`[Orchestrator] > Executing ${node.type.toUpperCase()} node: ${node.id} (${node.name})`);

        switch (node.type) {
            case 'llm':
                this.context.outputs[node.id] = await this._executeLLMNode(node);
                break;
            case 'function':
                this.context.outputs[node.id] = await this._executeFunctionNode(node);
                break;
            case 'router':
                // Router的执行只做决策，不改变图的状态
                await this._executeRouterNode(node);
                break;
            case 'map':
                await this._executeMapNode(node);
                break;
            default:
                throw new Error(`Unsupported node type: "${node.type}"`);
        }
    }

    async _executeLLMNode(node) {
        const nodeLabel = `${node.id} (${node.name})`;
        console.log(`[Pipeline] 🎯 Executing LLM node: ${nodeLabel}`);
        
        // 计算世界书信息
        const worldInfoContent = await this._calculateModuleWorldInfo(node);
        this.context.module = { worldInfo: worldInfoContent };
        const finalPrompt = this._renderPrompt(node, node.injectedParams);

        // =================== 详细的LLM调用预览 ===================
        console.log(`[Pipeline] ================== LLM CALL OVERVIEW: ${nodeLabel} ==================`);
        console.log(`[Pipeline] � Node: ${nodeLabel}`);
        console.log(`[Pipeline] 🤖 Model: ${node.llm.provider}/${node.llm.model}`);
        console.log(`[Pipeline] ⚙️  Config:`, {
            temperature: node.llm.temperature,
            maxOutputTokens: node.llm.maxOutputTokens,
            topP: node.llm.topP
        });
        console.log(`[Pipeline] 📏 Prompt Length: ${finalPrompt.length} characters`);
        console.log(`[Pipeline] 🌍 World Info Length: ${worldInfoContent ? worldInfoContent.length : 0} characters`);
        console.log(`[Pipeline] ⏰ Timestamp: ${new Date().toISOString()}`);
        console.log(`[Pipeline] 📝 Full Prompt:`);
        console.log(finalPrompt);
        console.log(`[Pipeline] ================== PROMPT END ==================`);

        try {
            const startTime = Date.now();
            const result = await dispatchLLM(finalPrompt, node.llm);
            const duration = Date.now() - startTime;

            // =================== 详细的LLM响应报告 ===================
            console.log(`[Pipeline] ================== LLM RESPONSE REPORT: ${nodeLabel} ==================`);
            console.log(`[Pipeline] 📋 Node: ${nodeLabel}`);
            console.log(`[Pipeline] ⏱️  Duration: ${duration}ms`);
            console.log(`[Pipeline] 📏 Response Length: ${result ? result.length : 0} characters`);
            
            if (!result || result.trim().length === 0) {
                console.warn(`[Pipeline] ⚠️  WARNING: EMPTY RESPONSE`);
                console.warn(`[Pipeline] 🔍 Check detailed API analysis above for diagnostic information`);
                console.log(`[Pipeline] 📝 Response Content: (EMPTY)`);
            } else {
                console.log(`[Pipeline] ✅ Success: Generated ${result.length} characters`);
                console.log(`[Pipeline] 📝 Full Response:`);
                console.log(result);
            }
            
            console.log(`[Pipeline] ================== RESPONSE END ==================`);

            return result || '';
            
        } catch (error) {
            console.error(`[Pipeline] ================== LLM ERROR REPORT: ${nodeLabel} ==================`);
            console.error(`[Pipeline] ❌ Error: ${error.message}`);
            console.error(`[Pipeline] 🔍 Full Error:`, error);
            console.error(`[Pipeline] ================== ERROR END ==================`);
            throw error;
        }
    }


    async _executeFunctionNode(node) {
        return executeFunction(node.functionName, this.context, node.params);
    }

    async _executeRouterNode(node) {
        const conditionValueRaw = this._resolvePath(node.condition.replace(/{{|}}/g, '').trim(), this.context);
        const conditionValue = String(conditionValueRaw).trim().toLowerCase();

        let chosenNextNodeId = null;
        for (const routeKey in node.routes) {
            // 支持用 'default' 作为备用路由
            if (routeKey.toLowerCase() === conditionValue) {
                chosenNextNodeId = node.routes[routeKey];
                break;
            }
        }

        // 如果没有精确匹配，检查是否有 'default' 路由
        if (!chosenNextNodeId && node.routes.default) {
            chosenNextNodeId = node.routes.default;
        }

        console.log(`[Router:${node.id}] Condition value is "${conditionValue}". Routing to -> ${chosenNextNodeId || 'end of branch'}.`);

        // 将决策结果存起来，以便 run 函数使用
        this.context.outputs[node.id] = { decision: chosenNextNodeId };
    }


    async _executeMapNode(node) {
        const list = this._resolvePath(node.inputListRef.replace(/{{|}}/g, '').trim(), this.context);
        const joinNodeId = node.joinNode;

        if (!Array.isArray(list) || list.length === 0) {
            console.warn(`[MapNode:${node.id}] Input list is empty or not an array. Informing join node.`);
            if (joinNodeId && this.nodes[joinNodeId]) {
                if (!this.nodes[joinNodeId].params) {
                    this.nodes[joinNodeId].params = {};
                }
                this.nodes[joinNodeId].params.sourceNodeIds = [];
            }
            return;
        }

        const templateNode = node.templateNode;
        const dynamicNodeIds = [];

        for (let i = 0; i < list.length; i++) {
            const item = list[i];
            const newNodeId = `${templateNode.id}_${i}`;

            const newNode = JSON.parse(JSON.stringify(templateNode));
            newNode.id = newNodeId;
            newNode.name = `${templateNode.name} for "${item}"`;
            newNode.injectedParams = { item: item };
            newNode.enabled = true;

            this.nodes[newNodeId] = newNode;
            this.nodeStates[newNodeId] = 'pending';
            dynamicNodeIds.push(newNodeId);

            // 动态节点的依赖是 Map 节点本身
            this.dependencies.set(newNodeId, new Set([node.id]));
            if (!this.dependents.has(node.id)) this.dependents.set(node.id, new Set());
            this.dependents.get(node.id).add(newNodeId);

            console.log(`[MapNode:${node.id}] Spawned dynamic node: ${newNodeId}`);
        }

        if (joinNodeId && this.nodes[joinNodeId]) {
            const joinNode = this.nodes[joinNodeId];
            const joinNodeDeps = this.dependencies.get(joinNodeId) || new Set();

            // JoinNode 依赖于所有动态生成的节点
            dynamicNodeIds.forEach(id => {
                joinNodeDeps.add(id);
                // 同时，建立反向依赖
                if (!this.dependents.has(id)) this.dependents.set(id, new Set());
                this.dependents.get(id).add(joinNodeId);
            });

            this.dependencies.set(joinNodeId, joinNodeDeps);

            if (!joinNode.params) joinNode.params = {};
            joinNode.params.sourceNodeIds = dynamicNodeIds; // 注入动态ID列表
        }
    }

    async run() {
        console.log('[Orchestrator V2] Starting dynamic graph execution...');
        this._initializeGraph();

        const inDegree = new Map();
        for (const nodeId in this.nodes) {
            inDegree.set(nodeId, this.dependencies.get(nodeId)?.size || 0);
        }

        let executionQueue = Object.keys(this.nodes).filter(nodeId => inDegree.get(nodeId) === 0);
        let completedOrSkippedCount = 0;

        while (executionQueue.length > 0) {
            console.log(`[Orchestrator] Executing parallel batch of ${executionQueue.length} nodes:`, executionQueue.map(id => this.nodes[id]?.name || id));

            const currentBatch = [...executionQueue];
            executionQueue = [];

            const promises = currentBatch.map(async (nodeId) => {
                try {
                    // 防御性检查，防止跳过的节点被错误执行
                    if (this.nodeStates[nodeId] !== 'pending') return;

                    this.nodeStates[nodeId] = 'running';
                    await this._executeNode(nodeId);
                    this.nodeStates[nodeId] = 'completed';
                } catch (error) {
                    this.nodeStates[nodeId] = 'failed';
                    const nodeName = this.nodes[nodeId]?.name || 'Unknown Node';
                    console.error(`Execution failed at node ${nodeName} (${nodeId}):`, error);
                    // 抛出错误以停止整个流程
                    throw new Error(`Execution failed at node ${nodeName}: ${error.message}`);
                }
            });

            await Promise.all(promises);

            // [!code focus:start]
            // ========================= 核心修正逻辑 START =========================
            // 在处理下游节点之前，检查刚刚完成的批次中是否有MapNode。
            // 如果有，图的结构已经改变，我们必须更新inDegree映射。
            for (const completedNodeId of currentBatch) {
                const node = this.nodes[completedNodeId];
                if (node.type === 'map') {
                    const joinNodeId = node.joinNode;
                    const dynamicNodeIds = this.nodes[joinNodeId]?.params?.sourceNodeIds || [];

                    // 1. 为所有新生成的动态节点设置初始inDegree
                    for (const dynamicNodeId of dynamicNodeIds) {
                        // 新节点在创建时已设置依赖，这里直接从 this.dependencies 获取
                        const initialDegree = this.dependencies.get(dynamicNodeId)?.size || 0;
                        inDegree.set(dynamicNodeId, initialDegree);

                        // 【补充检查】如果新节点的入度为0，它应该被加入下一个执行队列
                        // 但在你的设计中，动态节点的依赖是MapNode本身，所以它的入度至少为1，
                        // 并且会在MapNode完成后递减，所以这里的逻辑是安全的。
                    }

                    // 2. 更新JoinNode的inDegree，因为它获得了新的依赖
                    if (joinNodeId && this.nodes[joinNodeId]) {
                        // 【重要修正】这里的逻辑需要调整。不应该是 oldDegree + newDegree。
                        // 应该是直接从 this.dependencies 重新计算。
                        // 但考虑到拓扑排序的递减性质，更好的方法是增加它的 inDegree。
                        const currentDegree = inDegree.get(joinNodeId) || 0;
                        inDegree.set(joinNodeId, currentDegree + dynamicNodeIds.length);
                        console.log(`[GraphUpdate] JoinNode ${joinNodeId} inDegree increased by ${dynamicNodeIds.length}, new total: ${inDegree.get(joinNodeId)}`);
                    }
                }
            }
            // ========================= 核心修正逻辑 END =========================
            // [!code focus:end]


            let nodesToProcessForDependents = new Set(currentBatch);

            // 处理刚刚完成的节点，特别是Router
            for (const completedNodeId of currentBatch) {
                const node = this.nodes[completedNodeId];
                if (node.type === 'router') {
                    const decision = this.context.outputs[completedNodeId]?.decision;
                    for (const routeKey in node.routes) {
                        const targetNodeId = node.routes[routeKey];
                        if (targetNodeId !== decision && this.nodes[targetNodeId] && this.nodeStates[targetNodeId] === 'pending') {
                            this.nodeStates[targetNodeId] = 'skipped';
                            nodesToProcessForDependents.add(targetNodeId);
                            console.log(`[Router:${node.id}] Skipped node ${targetNodeId}`);
                        }
                    }
                }
            }

            completedOrSkippedCount += nodesToProcessForDependents.size;

            // 为所有新完成或跳过的节点，更新其下游节点的入度
            for (const processedNodeId of nodesToProcessForDependents) {
                const dependents = this.dependents.get(processedNodeId) || new Set();

                for (const dependentId of dependents) {
                    if (this.nodeStates[dependentId] === 'pending') {
                        const newDegree = (inDegree.get(dependentId) || 1) - 1;
                        inDegree.set(dependentId, newDegree);

                        if (newDegree === 0) {
                            executionQueue.push(dependentId);
                        }
                    }
                }
            }
        }

        const totalNodes = Object.keys(this.nodes).length;
        if (completedOrSkippedCount < totalNodes) {
            const unexecutedNodes = Object.keys(this.nodes).filter(id => this.nodeStates[id] === 'pending');
            const unexecutedNames = unexecutedNodes.map(id => this.nodes[id]?.name || id).join(', ');
            console.error(`[Orchestrator] Execution incomplete. ${unexecutedNodes.length} nodes were not executed, possibly due to a dependency cycle or graph error. Unexecuted:`, unexecutedNames);
            throw new Error(`Execution failed. Unexecuted nodes: ${unexecutedNames}`);
        }

        console.log("[Orchestrator] Pipeline finished. All outputs:", this.context.outputs);
        const finalOutput = this.context.outputs[this.finalOutputNodeId];
        return finalOutput || "Pipeline completed, but no final output was designated or the final node produced no output.";
    }
}
```

### utils/logging_example.js
```
// src/utils/logging_example.js

/**
 * 日志系统使用示例和配置指南
 */

import { DEBUG_CONFIG, setLogLevel } from './debug_config.js';
import { llmLogger } from './llm_logger.js';

// =============================================================================
// 使用示例
// =============================================================================

/**
 * 示例1：生产环境配置
 * 只显示警告和错误，保持日志简洁
 */
function setupProductionLogging() {
    setLogLevel('WARN');
    DEBUG_CONFIG.LLM_LOGS.INCLUDE_FULL_PROMPT = false;
    DEBUG_CONFIG.LLM_LOGS.INCLUDE_FULL_RESPONSE = false;
    
    console.log('✅ Production logging configured - minimal output');
}

/**
 * 示例2：开发环境配置
 * 显示详细信息，便于调试
 */
function setupDevelopmentLogging() {
    setLogLevel('DEBUG');
    DEBUG_CONFIG.LLM_LOGS.INCLUDE_FULL_PROMPT = true;
    DEBUG_CONFIG.LLM_LOGS.INCLUDE_FULL_RESPONSE = true;
    
    console.log('✅ Development logging configured - verbose output');
}

/**
 * 示例3：故障排除配置
 * 专注于错误分析和空响应诊断
 */
function setupTroubleshootingLogging() {
    setLogLevel('INFO');
    DEBUG_CONFIG.LLM_LOGS.EMPTY_RESPONSE_ANALYSIS = true;
    DEBUG_CONFIG.LLM_LOGS.INCLUDE_API_DETAILS = true;
    
    console.log('✅ Troubleshooting logging configured - focused on issues');
}

/**
 * 示例4：静默模式
 * 只记录严重错误
 */
function setupSilentLogging() {
    setLogLevel('ERROR');
    Object.keys(DEBUG_CONFIG).forEach(key => {
        if (typeof DEBUG_CONFIG[key] === 'object') {
            Object.keys(DEBUG_CONFIG[key]).forEach(subKey => {
                if (subKey !== 'ENABLED') {
                    DEBUG_CONFIG[key][subKey] = false;
                }
            });
        }
    });
    
    console.log('✅ Silent logging configured - errors only');
}

// =============================================================================
// 快速配置函数
// =============================================================================

/**
 * 根据环境自动配置日志
 */
export function autoConfigureLogging() {
    const isDevelopment = process.env.NODE_ENV === 'development' || 
                         window.location.hostname === 'localhost';
    
    if (isDevelopment) {
        setupDevelopmentLogging();
    } else {
        setupProductionLogging();
    }
}

/**
 * 运行时切换日志级别
 */
export function switchLoggingMode(mode) {
    switch (mode.toLowerCase()) {
        case 'production':
        case 'prod':
            setupProductionLogging();
            break;
        case 'development':
        case 'dev':
            setupDevelopmentLogging();
            break;
        case 'troubleshoot':
        case 'debug':
            setupTroubleshootingLogging();
            break;
        case 'silent':
        case 'quiet':
            setupSilentLogging();
            break;
        default:
            console.warn(`Unknown logging mode: ${mode}`);
            console.log('Available modes: production, development, troubleshoot, silent');
    }
}

// =============================================================================
// 浏览器控制台辅助函数
// =============================================================================

/**
 * 在浏览器控制台中可用的调试函数
 */
if (typeof window !== 'undefined') {
    window.HevnoLogging = {
        // 快速切换日志模式
        setMode: switchLoggingMode,
        
        // 获取当前配置
        getConfig: () => DEBUG_CONFIG,
        
        // 分析最近的空响应（如果有的话）
        analyzeLastEmpty: () => {
            console.log('This would analyze the last empty response if tracking was enabled');
        },
        
        // 显示帮助信息
        help: () => {
            console.log(`
🔧 Hevno Logging Controls:

HevnoLogging.setMode('production')    - 生产模式（简洁日志）
HevnoLogging.setMode('development')   - 开发模式（详细日志）
HevnoLogging.setMode('troubleshoot')  - 故障排除模式
HevnoLogging.setMode('silent')        - 静默模式（仅错误）

HevnoLogging.getConfig()              - 查看当前配置
HevnoLogging.help()                   - 显示此帮助

Example:
  HevnoLogging.setMode('dev')         - 切换到开发模式
            `);
        }
    };
    
    console.log('🔧 Hevno logging controls available. Type HevnoLogging.help() for commands.');
}

// =============================================================================
// 自动初始化
// =============================================================================

// 自动配置（如果没有手动配置的话）
if (typeof window !== 'undefined' && !window.HEVNO_LOGGING_CONFIGURED) {
    autoConfigureLogging();
    window.HEVNO_LOGGING_CONFIGURED = true;
}

```

### utils/llm_logger.js
```
// src/utils/llm_logger.js

import { DEBUG_CONFIG, shouldLog, getLogConfig } from './debug_config.js';

/**
 * LLM调用专用分析工具
 * 专注于问题诊断和深度分析，不重复基础日志
 */
export class LLMLogger {
    
    /**
     * 记录空响应的详细分析（这是最重要的功能）
     */
    static logEmptyResponse(sessionId, prompt, llmConfig, apiResponse, context = {}) {
        const timestamp = new Date().toISOString();
        
        console.group(`🔍 [LLM-Analysis] EMPTY RESPONSE - ${sessionId} - ${timestamp}`);
        console.warn('⚠️  Empty response detected, analyzing possible causes...');
        
        // 基本信息
        console.log('📋 Context:', {
            promptLength: prompt.length,
            model: llmConfig.model,
            temperature: llmConfig.temperature,
            maxTokens: llmConfig.maxOutputTokens,
            apiKey: context.apiKey ? `...${context.apiKey.slice(-4)}` : 'unknown'
        });
        
        // 分析API响应结构
        console.group('🕵️  API Response Analysis:');
        
        if (!apiResponse.candidates || apiResponse.candidates.length === 0) {
            console.warn('❌ No candidates returned by API - possible request rejection');
        } else {
            console.log(`✅ ${apiResponse.candidates.length} candidate(s) available`);
            
            const candidate = apiResponse.candidates[0];
            if (candidate.finishReason !== 'STOP') {
                console.warn(`❌ Unusual finish reason: ${candidate.finishReason}`);
                if (candidate.finishReason === 'SAFETY') {
                    console.warn('🛡️  Content filtered by safety system');
                } else if (candidate.finishReason === 'MAX_TOKENS') {
                    console.warn('📏 Response truncated due to token limit');
                }
            }
        }
        
        if (apiResponse.promptFeedback) {
            console.warn('🛡️  Prompt feedback (content policy):');
            console.warn(apiResponse.promptFeedback);
        }
        
        if (apiResponse.safetyRatings && apiResponse.safetyRatings.length > 0) {
            const blockedRatings = apiResponse.safetyRatings.filter(rating => 
                rating.probability === 'HIGH' || rating.probability === 'MEDIUM'
            );
            if (blockedRatings.length > 0) {
                console.warn('🚨 Safety concerns detected:');
                blockedRatings.forEach(rating => {
                    console.warn(`  - ${rating.category}: ${rating.probability}`);
                });
            }
        }
        
        console.groupEnd();
        
        // 分析可能的原因
        console.group('💡 Possible Solutions:');
        
        if (prompt.length > 30000) {
            console.log('📏 Try reducing prompt length (current: >30k chars)');
        }
        
        if (llmConfig.maxOutputTokens && llmConfig.maxOutputTokens < 100) {
            console.log('🔧 Try increasing maxOutputTokens (current: <100)');
        }
        
        if (llmConfig.temperature === 0) {
            console.log('🎲 Try increasing temperature for more creativity');
        }
        
        if (apiResponse.promptFeedback || (apiResponse.safetyRatings && apiResponse.safetyRatings.length > 0)) {
            console.log('📝 Try rephrasing prompt to avoid content policy triggers');
        }
        
        if (context.retryAttempt > 1) {
            console.log('🔄 Consider checking API key quota and status');
        }
        
        console.groupEnd();
        console.groupEnd();
    }
    
    /**
     * 生成会话ID用于跟踪单次LLM调用
     */
    static generateSessionId() {
        return Math.random().toString(36).substring(2, 8).toUpperCase();
    }
    
    /**
     * 分析API错误
     */
    static analyzeError(error, context = {}) {
        console.group('🔍 [LLM-Analysis] ERROR ANALYSIS');
        
        if (error.status === 429) {
            console.error('🚫 Rate limit exceeded - API quota exhausted');
            console.log('💡 Solutions: Wait for quota reset, use different API key, or reduce request frequency');
        } else if (error.status === 401 || error.status === 403) {
            console.error('🔑 Authentication/Authorization failed');
            console.log('💡 Solutions: Check API key validity, permissions, and billing status');
        } else if (error.status >= 500) {
            console.error('🔥 Server error - API service issue');
            console.log('💡 Solutions: Retry after delay, check API status page');
        } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
            console.error('🌐 Network connectivity issue');
            console.log('💡 Solutions: Check internet connection, proxy settings, firewall');
        } else {
            console.error(`❓ Unknown error: ${error.name} - ${error.message}`);
        }
        
        if (context.apiKey) {
            console.log(`🔑 API Key: ...${context.apiKey.slice(-4)}`);
        }
        
        console.groupEnd();
    }
}

// 全局可用的便捷函数
export const llmLogger = LLMLogger;

```

### utils/debug_config.js
```
// src/utils/debug_config.js

/**
 * 调试和日志配置
 * 用于控制整个系统的日志输出级别
 */
export const DEBUG_CONFIG = {
    // 日志级别: 'DEBUG', 'INFO', 'WARN', 'ERROR'
    LOG_LEVEL: 'DEBUG',
    
    // LLM相关日志
    LLM_LOGS: {
        ENABLED: true,
        INCLUDE_FULL_PROMPT: true,
        INCLUDE_FULL_RESPONSE: true,
        INCLUDE_API_DETAILS: true,
        EMPTY_RESPONSE_ANALYSIS: true
    },
    
    // 节点执行日志
    NODE_EXECUTION: {
        ENABLED: true,
        INCLUDE_TIMING: true,
        INCLUDE_CONTEXT: true
    },
    
    // API密钥管理日志
    API_KEY_MANAGEMENT: {
        ENABLED: true,
        INCLUDE_KEY_ROTATION: true,
        INCLUDE_FAILURE_DETAILS: true
    },
    
    // 世界书日志
    WORLD_INFO: {
        ENABLED: true,
        INCLUDE_LOADING_DETAILS: true,
        INCLUDE_MUTEX_INFO: true
    }
};

/**
 * 设置日志级别
 */
export function setLogLevel(level) {
    DEBUG_CONFIG.LOG_LEVEL = level;
    console.log(`[Debug Config] Log level set to: ${level}`);
}

/**
 * 检查是否应该记录特定级别的日志
 */
export function shouldLog(level) {
    const levels = ['DEBUG', 'INFO', 'WARN', 'ERROR'];
    const currentLevelIndex = levels.indexOf(DEBUG_CONFIG.LOG_LEVEL);
    const requestedLevelIndex = levels.indexOf(level);
    return requestedLevelIndex >= currentLevelIndex;
}

/**
 * 获取特定功能的日志配置
 */
export function getLogConfig(feature) {
    return DEBUG_CONFIG[feature] || { ENABLED: false };
}

```

### data/defaultPipeline.js
```
export const defaultPipeline = [
    // =================================================================
    // 阶段 1: 故事创作与角色识别
    // =================================================================
    
    // 节点 1: 故事生成器
    {
        "id": "story_generator",
        "name": "1. 故事生成器",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.8 },
        "worldInfo": ["world_info"], // 使用正确的世界书名称（不带.json扩展名）
        "promptSlots": [{
            "enabled": true,
            "content": "你是一位富有想象力的小说家。请根据用户的请求，创作一个包含多个角色的、戏剧性的中世纪奇幻小说。场景描述需要生动，并明确介绍至少两名出场角色的名字和简要特征，为后续情节发展埋下伏笔。\n\n用户请求:\n{{sillyTavern.userInput}}\n\n# 世界信息:{{module.worldInfo}}\n\n你的输出必须是一段200字以上的流畅的故事，不能包含任何控制文本或者指令。"
        }]
    },
    
    // 节点 2: 角色识别LLM
    {
        "id": "character_identifier_llm",
        "name": "2. LLM识别角色",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.1 },
        "promptSlots": [{
            "enabled": true,
            "content": "分析工具：严格按照 'Characters: 角色A, 角色B, 角色C' 的格式，从以下文本中提取所有被命名的角色。如果一个角色都没有，必须输出 'Characters: None'。不要添加任何其他解释或前言。\n\n文本：\n{{outputs.story_generator}}"
        }]
    },

    // 节点 3: 解析角色列表 (使用保留的便利函数)
    // 尽管有更通用的regexExtract，但parseCharacterList对于这个常见任务更方便。
    {
        "id": "parse_character_list",
        "name": "3. 解析角色列表",
        "enabled": true,
        "type": "function",
        "functionName": "parseCharacterList",
        "params": { "sourceNode": "character_identifier_llm" }
    },

    // =================================================================
    // 阶段 2: 动态角色行动分析 (Map/Reduce 模式)
    // =================================================================

    // 节点 4: Map节点 - 为每个角色生成行动分析
    {
        "id": "dynamic_character_analysis_map",
        "name": "4. 动态角色分析 (Map)",
        "enabled": true,
        "type": "map",
        "inputListRef": "{{outputs.parse_character_list}}",
        "joinNode": "aggregate_character_actions", // 指定下一步的聚合节点
        "templateNode": { // 这是为每个角色动态创建的LLM节点的模板
            "id": "character_action_template", // 临时ID
            "name": "角色行动分析模板",
            "type": "llm",
            "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.7 },
            "worldInfo": ["character_info"], // 使用正确的世界书名称（不带.json扩展名）
            "promptSlots": [{
                "enabled": true,
                "content": "当前场景中有一位名叫 '{{item}}' 的角色。基于TA的背景故事和当前场景，设想TA接下来最可能的一个具体行动和一段内心独白。以第三人称小说风格进行描述。\n\n# 角色 '{{item}}' 的背景\n{{module.worldInfo}}\n\n# 当前场景\n{{outputs.story_generator}}"
            }]
        }
    },

    // 节点 5: Join/Reduce节点 - 聚合所有角色的行动
    // 【重大改进】使用新的 'joinFromDynamicNodes' 函数
    {
        "id": "aggregate_character_actions",
        "name": "5. 聚合角色行动",
        "enabled": true,
        "type": "function",
        "functionName": "joinFromDynamicNodes",
        "params": {
            // itemTemplate 定义了每个动态节点的输出如何被格式化
            "itemTemplate": "关于角色“{{item}}”的行动构想：\n{{output}}",
            // separator 定义了各项之间如何连接
            "separator": "\n\n"
        }
    },

    // =================================================================
    // 阶段 3: 剧情分支 (Router 模式)
    // =================================================================
    
    // 节点 6: 战斗检查LLM
    {
        "id": "combat_check_llm",
        "name": "6. LLM检查战斗可能性",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.0 }, // temperature=0.0 使输出更稳定
        "promptSlots": [{
            "enabled": true,
            "content": "分析以下场景描述中是否隐含了即将发生的物理冲突或战斗意图。你的回答只能是 'Yes' 或 'No'，不要包含任何其他字符或解释。\n\n场景:\n{{outputs.aggregate_character_actions}}"
        }]
    },
    
    // 节点 7: 战斗决策路由器
    // 【重大改进】这里不直接用 combat_check_llm 的输出，而是先通过一个函数节点返回布尔值，
    // 这样路由器的条件就是 "true" 或 "false"，更加稳健。
    // (虽然直接匹配 "Yes" 也可以，但这是一个展示组合性的好例子)
    {
        "id": "combat_decision_function",
        "name": "7. 战斗决策函数",
        "enabled": true,
        "type": "function",
        "functionName": "textContains",
        "params": {
            "sourceNode": "combat_check_llm",
            "keyword": "Yes",
            "caseSensitive": false
        }
    },
    
    // 节点 8: 战斗路由器
    {
        "id": "combat_router",
        "name": "8. 战斗路由器",
        "enabled": true,
        "type": "router",
        "condition": "{{outputs.combat_decision_function}}", // 依赖函数节点的布尔输出
        "routes": { 
            "true": "combat_module",    // 如果是 true，走向战斗分支
            "false": "peaceful_module"  // 如果是 false，走向和平分支
        }
    },

    // 节点 9a & 9b: 剧情分支
    {
        "id": "combat_module",
        "name": "9a. 战斗流程",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.9 },
        "promptSlots": [{ "enabled": true, "content": "续写下面的故事，引入一场激烈的战斗。详细描写战斗的起因和最初的几个回合。\n\n故事背景：\n{{outputs.aggregate_character_actions}}" }]
    },
    {
        "id": "peaceful_module",
        "name": "9b. 和平流程",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.6 },
        "promptSlots": [{ "enabled": true, "content": "续写下面的故事，展开一段充满紧张感的对话或非暴力冲突。聚焦于角色的心理博弈和潜台词。\n\n故事背景：\n{{outputs.aggregate_character_actions}}" }]
    },

    // =================================================================
    // 阶段 4: 最终整合与清理
    // =================================================================

    // 节点 10: 最终整合器
    {
        "id": "final_formatter",
        "name": "10. 最终整合器",
        "enabled": true,
        "type": "llm",
        "llm": { "provider": "gemini", "model": "gemini-2.5-flash", "temperature": 0.5 },
        "promptSlots": [{
            "enabled": true,
            // 这个 prompt 现在可以安全地处理空输入了，因为 {{outputs.combat_module}} 或 {{outputs.peaceful_module}}
            // 在被跳过时，模板渲染会将其视为空字符串。
            "content": "你是一位优秀的故事编辑。你的任务是优化和完善下面的“主要故事文本”。\n如果下面的“附加续写”部分有内容，请将其无缝地融入主要故事文本中，形成一个连贯、流畅的故事段落。如果“附加续写”部分为空，你只需对“主要故事文本”进行润色和续写，确保它有一个自然的结尾即可。\n你的最终输出必须是完整的故事，不要包含任何解释或标签。\n\n[主要故事文本]\n{{outputs.story_generator}}\n\n[附加续写]\n{{outputs.combat_module}}{{outputs.peaceful_module}}"
        }]
    }
];
```

### data/pluginSetting.js
```
import { defaultPipeline } from './defaultPipeline.js';

export const defaultSettings = {
    isEnabled: true,
    demoString: "This message was intercepted and replaced by the Hevno plugin.",
    pipeline: defaultPipeline, 
    geminiApiKeys: [],
};
```

### scripts/settings/userExtensionSetting.js
```
// src/scripts/settings/userExtensionSetting.js

import { USER } from '../../core/manager.js';
import { apiKeyManager } from '../../core/apiKeyManager.js';

/**
 * 验证导入的管线对象是否具有基本结构。
 * @param {any} data - 从JSON文件解析出的数据。
 * @returns {boolean} - 如果数据结构有效则返回true。
 */
function isValidPipeline(data) {
    if (!Array.isArray(data)) {
        toastr.error("Invalid pipeline: The file content is not an array.", "Import Error");
        return false;
    }
    if (data.length === 0) {
        toastr.warning("Imported pipeline is empty.", "Import Warning");
        return true; // 空管线是有效的
    }
    const firstModule = data[0];
    if (typeof firstModule !== 'object' || firstModule === null || !('id' in firstModule) || !('name' in firstModule) || !('promptSlots' in firstModule)) {
        toastr.error("Invalid pipeline: Modules are missing required properties (id, name, promptSlots).", "Import Error");
        return false;
    }
    return true;
}

/**
 * 【新增】处理管线导出逻辑。
 */
function handleExportPipeline() {
    try {
        const currentPipeline = USER.settings.pipeline;
        const jsonString = JSON.stringify(currentPipeline, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        
        // 创建一个临时的下载链接
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `hevno-pipeline-${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a);
        a.click();
        
        // 清理
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        toastr.success("Pipeline exported successfully!", "Export Complete");
    } catch (error) {
        console.error("[Hevno] Failed to export pipeline:", error);
        toastr.error("An error occurred while exporting the pipeline.", "Export Error");
    }
}

/**
 * 【新增】处理文件选择和管线导入逻辑。
 * @param {Event} event - 文件输入框的change事件。
 */
function handleImportPipeline(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const content = e.target.result;
            const importedPipeline = JSON.parse(content);

            if (isValidPipeline(importedPipeline)) {
                // 验证通过，保存到设置中
                // USER.settings的Proxy会自动调用saveSettingsDebounced()
                USER.settings.pipeline = importedPipeline;
                toastr.success("Pipeline imported and saved successfully!", "Import Complete");
            }
        } catch (error) {
            console.error("[Hevno] Failed to import pipeline:", error);
            toastr.error(`Failed to read or parse the pipeline file: ${error.message}`, "Import Error");
        } finally {
            // 重置文件输入框，以便可以再次选择同一个文件
            event.target.value = '';
        }
    };
    reader.onerror = () => {
        toastr.error("Failed to read the selected file.", "File Read Error");
    };

    reader.readAsText(file);
}

/**
 * 渲染设置界面的当前值
 */
export function renderSettings() {
    $('#Hevno_enabled_switch').prop('checked', USER.settings.isEnabled);
    $('#Hevno_demo_string_input').val(USER.settings.demoString);

    const keys = USER.settings.geminiApiKeys || [];
    $('#hevno_gemini_keys_textarea').val(keys.join('\n'));
}

/**
 * 绑定UI元素的事件监听
 */
function bindEvents() {
    // 原有事件
    $('#Hevno_enabled_switch').on('change', function() {
        USER.settings.isEnabled = $(this).is(':checked');
    });
    $('#Hevno_demo_string_input').on('input', function() {
        USER.settings.demoString = $(this).val();
    });

    // 【新增】为新按钮和文件输入框绑定事件
    $('#hevno_export_pipeline_btn').on('click', handleExportPipeline);
    
    // 点击“导入”按钮时，实际触发隐藏的文件输入框
    $('#hevno_import_pipeline_btn').on('click', () => {
        $('#hevno_pipeline_file_input').click();
    });

    // 当用户选择了文件后，处理文件内容
    $('#hevno_pipeline_file_input').on('change', handleImportPipeline);

        $('#hevno_gemini_keys_textarea').on('input', function() {
        const keysString = $(this).val();
        const keysArray = keysString.split('\n').map(k => k.trim()).filter(k => k);
        USER.settings.geminiApiKeys = keysArray;
        // 立即通知密钥管理器更新其密钥池
        apiKeyManager.loadKeys();
    });
}

/**
 * 加载设置的主函数
 */
export function loadSettings() {
    renderSettings();
    bindEvents();
    apiKeyManager.loadKeys();
    console.log("[Hevno] Settings UI loaded and pipeline management events bound.");
}
```
