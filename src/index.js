// src/index.js (附有详细注释文档)

/**
 * @file index.js
 * @description 插件的主入口文件。
 * @version 1.1.0
 *
 * @summary
 * 该文件负责插件的初始化，包括：
 * 1.  向SillyTavern页面注入插件的设置UI。
 * 2.  注册核心的生成拦截器 `HevnoInterceptor`，这是插件所有功能的核心。
 *
 * 【新开发者必读】
 * 插件的生命周期从 `jQuery(async () => { ... });` 开始，这确保了代码在页面DOM加载完毕后执行。
 * 核心逻辑位于 `globalThis.HevnoInterceptor` 函数中，请务必理解其工作流程。
 */

import { APP, USER, SYSTEM } from './core/manager.js';
import { loadSettings } from './scripts/settings/userExtensionSetting.js';

console.log("______________________ Hevno Plugin: Loading ______________________");

/**
 * @function HevnoInterceptor
 * @global
 * @description (!!!) 插件的核心 - 生成拦截器。
 *
 * 【关键概念：生成拦截器 (Generation Interceptor)】
 * 这是通过 `manifest.json`中的 `generate_interceptor` 字段注册到SillyTavern的全局函数。
 * 在SillyTavern每次准备向LLM发送请求之前，它会“暂停”并调用这个函数，给予插件干预的机会。
 *
 * 【核心工作流：拦截 -> 执行 -> 喂回】
 * 这个函数的设计遵循了一个健壮的模式，以确保与SillyTavern的深度和安全集成：
 * 1.  **拦截 (Intercept)**: 通过调用 `abort(true)`，我们立即中止SillyTavern的默认生成流程，完全接管控制权。
 * 2.  **执行 (Execute)**: 这是我们插件自定义逻辑的执行阶段。在这里，我们可以进行自己的LLM调用、
 *     数据处理，或者像这个例子一样，简单地准备一个固定的字符串。
 * 3.  **喂回 (Feed-back)**: 我们不直接操作DOM，而是将我们的最终结果通过 `APP.saveReply()` 函数
 *     “喂回”给SillyTavern。SillyTavern会像处理一个真实的AI回复一样，负责后续所有的UI渲染、
 *     事件触发和状态更新。这是最推荐的集成方式。
 * 4.  **清理 (Cleanup)**: 在 `finally` 块中，必须调用 `APP.unblockGeneration()` 来解锁UI，
 *     无论流程成功与否，这都能防止界面卡死。
 *
 * @param {Array} chat - 即将用于构建prompt的聊天历史数组（在此模式下我们通常不直接修改它）。
 * @param {Number} contextSize - 当前的token计数。
 * @param {Function} abort - 中止函数。调用 `abort(true)` 来中止并阻止其他拦截器运行。
 * @param {String} type - 触发生成的类型 (e.g., 'send', 'regenerate', 'swipe')。
 */
globalThis.HevnoInterceptor = async function(chat, contextSize, abort, type) {
    const settings = USER.settings;

    // 步骤 0: 前置检查。如果插件被禁用，则直接返回，让SillyTavern继续正常流程。
    if (!settings.isEnabled) {
        return;
    }

    console.log(`[Hevno] Intercepting generation of type: ${type}`);

    // 步骤 1: 【拦截】中止SillyTavern的原始生成流程。
    abort(true);

    try {
        // 步骤 2: 【执行】执行插件的自定义逻辑。
        // 在这个简单的雏形中，我们只是从设置里获取一个字符串。
        // 在未来的复杂插件中，这里可以替换为对 `APP.generateRaw()` 的多次调用和结果处理。
        const finalOutput = settings.demoString;

        if (!finalOutput) {
            console.warn("[Hevno] Demo string is empty, nothing to generate.");
            return;
        }

        // 步骤 3: 【喂回】将结果交给SillyTavern的核心处理函数。
        // `saveReply` 会负责创建消息、渲染UI、触发事件等所有后续工作。
        await APP.saveReply({
            type: 'normal',
            getMessage: finalOutput,
            title: 'Generated by Hevno Plugin',
        });

        // 步骤 4: 【持久化】调用SillyTavern的保存函数来保存新的聊天记录。
        await APP.saveChatConditional();

        console.log(`[Hevno] Generation aborted and replaced with demo message via saveReply.`);

    } catch (error) {
        console.error("[Hevno] An error occurred during the interception process:", error);
        toastr.error("The Hevno Plugin encountered an error.", "Plugin Error");
    } finally {
        // 步骤 5: 【清理】(!!!) 关键步骤！无论成功还是失败，都必须调用此函数来解锁UI。
        APP.unblockGeneration(type);
    }
};

/**
 * 插件的主初始化函数。
 * 使用 jQuery(async () => { ... }) 确保在文档对象模型(DOM)完全加载和解析完毕后执行。
 * 这是Web开发的标准实践，可以防止因尝试操作不存在的元素而导致的错误。
 */
jQuery(async () => {
    // 任务1: 注入插件的设置UI界面。
    try {
        // 使用我们封装的 SYSTEM 管理器来异步加载HTML模板。
        const settingsHtml = await SYSTEM.getTemplate('settings');

        // 使用jQuery将加载的HTML内容附加到SillyTavern的扩展设置面板中。
        // '#extensions_settings' 是SillyTavern中用于放置所有插件设置的容器ID。
        $('#extensions_settings').append(settingsHtml);

        // 加载设置的初始值并为UI元素绑定事件监听器。
        loadSettings();

    } catch (error) {
        console.error("[Hevno] Failed to load settings UI.", error);
    }
    
    console.log("______________________ Hevno Plugin: Loaded Successfully ______________________");
});