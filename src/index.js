// src/index.js (附有详细注释文档)

/**
 * @file index.js
 * @description 插件的主入口文件。
 * @version 1.1.0
 *
 * @summary
 * 该文件负责插件的初始化，包括：
 * 1.  向SillyTavern页面注入插件的设置UI。
 * 2.  注册核心的生成拦截器 `HevnoInterceptor`，这是插件所有功能的核心。
 *
 * 【新开发者必读】
 * 插件的生命周期从 `jQuery(async () => { ... });` 开始，这确保了代码在页面DOM加载完毕后执行。
 * 核心逻辑位于 `globalThis.HevnoInterceptor` 函数中，请务必理解其工作流程。
 */

import { APP, USER, SYSTEM } from './core/manager.js';
import { loadSettings } from './scripts/settings/userExtensionSetting.js';
import { GenerationOrchestrator } from './core/orchestrator.js';
import { defaultPipeline } from './data/defaultPipeline.js';

console.log("______________________ Hevno Plugin: Loading ______________________");

/**
 * @function HevnoInterceptor
 * @global
 * @description (!!!) 插件的核心 - 生成拦截器。
 *
 * 【关键概念：生成拦截器 (Generation Interceptor)】
 * 这是通过 `manifest.json`中的 `generate_interceptor` 字段注册到SillyTavern的全局函数。
 * 在SillyTavern每次准备向LLM发送请求之前，它会“暂停”并调用这个函数，给予插件干预的机会。
 *
 * 【核心工作流：拦截 -> 执行 -> 喂回】
 * 这个函数的设计遵循了一个健壮的模式，以确保与SillyTavern的深度和安全集成：
 * 1.  **拦截 (Intercept)**: 通过调用 `abort(true)`，我们立即中止SillyTavern的默认生成流程，完全接管控制权。
 * 2.  **执行 (Execute)**: 这是我们插件自定义逻辑的执行阶段。在这里，我们可以进行自己的LLM调用、
 *     数据处理，或者像这个例子一样，简单地准备一个固定的字符串。
 * 3.  **喂回 (Feed-back)**: 我们不直接操作DOM，而是将我们的最终结果通过 `APP.saveReply()` 函数
 *     “喂回”给SillyTavern。SillyTavern会像处理一个真实的AI回复一样，负责后续所有的UI渲染、
 *     事件触发和状态更新。这是最推荐的集成方式。
 * 4.  **清理 (Cleanup)**: 在 `finally` 块中，必须调用 `APP.unblockGeneration()` 来解锁UI，
 *     无论流程成功与否，这都能防止界面卡死。
 *
 * @param {Array} chat - 即将用于构建prompt的聊天历史数组（在此模式下我们通常不直接修改它）。
 * @param {Number} contextSize - 当前的token计数。
 * @param {Function} abort - 中止函数。调用 `abort(true)` 来中止并阻止其他拦截器运行。
 * @param {String} type - 触发生成的类型 (e.g., 'send', 'regenerate', 'swipe')。
 */
globalThis.HevnoInterceptor = async function(chat, contextSize, abort, type) {
    const settings = USER.settings;

    if (!settings.isEnabled) {
        return;
    }

    console.log(`[Hevno] Intercepting generation of type: ${type}`);
    abort(true);

    try {
        // 步骤 2: 【执行】使用我们的新编排器执行模块化生成
        console.log("[Hevno] Starting modular generation pipeline...");

        // 在真实插件中，这个pipelineDefinition可以从用户设置或文件中加载
        const pipelineDefinition = defaultPipeline; 

        const orchestrator = new GenerationOrchestrator(pipelineDefinition, APP.getContext());
        
        // 运行管线并获取最终结果
        const finalOutput = await orchestrator.run();

        if (!finalOutput) {
            console.warn("[Hevno] Pipeline ran, but produced no final output.");
            return;
        }
        
        // 步骤 3: 【喂回】将结果交给SillyTavern
        await APP.saveReply({
            type: 'normal',
            getMessage: finalOutput,
            title: 'Generated by Hevno Modular Pipeline',
        });

        // 步骤 4: 【持久化】保存聊天
        await APP.saveChatConditional();

        console.log(`[Hevno] Generation completed via modular pipeline.`);

    } catch (error) {
        console.error("[Hevno] An error occurred during the modular pipeline execution:", error);
        toastr.error("The Hevno Plugin encountered an error during its pipeline.", "Pipeline Error");
    } finally {
        // 步骤 5: 【清理】解锁UI
        APP.unblockGeneration(type);
    }
};
/**
 * 插件的主初始化函数。
 * 使用 jQuery(async () => { ... }) 确保在文档对象模型(DOM)完全加载和解析完毕后执行。
 * 这是Web开发的标准实践，可以防止因尝试操作不存在的元素而导致的错误。
 */
jQuery(async () => {
    // 任务1: 注入插件的设置UI界面。
    try {
        // 使用我们封装的 SYSTEM 管理器来异步加载HTML模板。
        const settingsHtml = await SYSTEM.getTemplate('settings');

        // 使用jQuery将加载的HTML内容附加到SillyTavern的扩展设置面板中。
        // '#extensions_settings' 是SillyTavern中用于放置所有插件设置的容器ID。
        $('#extensions_settings').append(settingsHtml);

        // 加载设置的初始值并为UI元素绑定事件监听器。
        loadSettings();

    } catch (error) {
        console.error("[Hevno] Failed to load settings UI.", error);
    }
    
    console.log("______________________ Hevno Plugin: Loaded Successfully ______________________");
});